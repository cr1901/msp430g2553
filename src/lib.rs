# ! [ feature ( abi_msp430_interrupt ) ]
# ! [ cfg_attr ( feature = "rt" , feature ( global_asm ) ) ]
# ! [ cfg_attr ( feature = "rt" , feature ( linkage ) ) ]
# ! [ cfg_attr ( feature = "rt" , feature ( used ) ) ]
# ! [ cfg_attr ( feature = "rt" , feature ( use_extern_macros ) ) ]
# ! [ doc = "Peripheral access API for MSP430G2553 microcontrollers (generated using svd2rust v0.11.2)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.11.2/svd2rust/#peripheral-api" ]
# ! [ deny ( missing_docs ) ]
# ! [ deny ( warnings ) ]
# ! [ allow ( non_camel_case_types ) ]
# ! [ feature ( const_fn ) ]
# ! [ no_std ]
#[cfg(feature = "rt")]
extern crate msp430_rt ;
extern crate bare_metal ;
extern crate vcell ;
#[cfg(feature = "rt")]
pub use msp430_rt::default_handler;
use core::ops::Deref;
use bare_metal::Peripheral;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[cfg(feature = "rt")]
    global_asm!(
        "\n.weak TRAPINT\nTRAPINT = DEFAULT_HANDLER\n.weak PORT1\nPORT1 = DEFAULT_HANDLER\n.weak PORT2\nPORT2 = DEFAULT_HANDLER\n.weak ADC10\nADC10 = DEFAULT_HANDLER\n.weak USCIAB0TX\nUSCIAB0TX = DEFAULT_HANDLER\n.weak USCIAB0RX\nUSCIAB0RX = DEFAULT_HANDLER\n.weak TIMER0_A1\nTIMER0_A1 = DEFAULT_HANDLER\n.weak TIMER0_A0\nTIMER0_A0 = DEFAULT_HANDLER\n.weak WDT\nWDT = DEFAULT_HANDLER\n.weak COMPARATORA\nCOMPARATORA = DEFAULT_HANDLER\n.weak TIMER1_A1\nTIMER1_A1 = DEFAULT_HANDLER\n.weak TIMER1_A0\nTIMER1_A0 = DEFAULT_HANDLER\n.weak NMI\nNMI = DEFAULT_HANDLER"
    );
    #[cfg(feature = "rt")]
    extern "msp430-interrupt" {
        fn TRAPINT();
        fn PORT1();
        fn PORT2();
        fn ADC10();
        fn USCIAB0TX();
        fn USCIAB0RX();
        fn TIMER0_A1();
        fn TIMER0_A0();
        fn WDT();
        fn COMPARATORA();
        fn TIMER1_A1();
        fn TIMER1_A0();
        fn NMI();
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS : [ Option < unsafe extern "msp430-interrupt" fn ( ) > ; 15 ] = [ Some ( TRAPINT ) , None , Some ( PORT1 ) , Some ( PORT2 ) , None , Some ( ADC10 ) , Some ( USCIAB0TX ) , Some ( USCIAB0RX ) , Some ( TIMER0_A1 ) , Some ( TIMER0_A0 ) , Some ( WDT ) , Some ( COMPARATORA ) , Some ( TIMER1_A1 ) , Some ( TIMER1_A0 ) , Some ( NMI ) , ] ;
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - 0xFFE0 TRAPINT"]
        TRAPINT,
        #[doc = "2 - 0xFFE4 Port 1"]
        PORT1,
        #[doc = "3 - 0xFFE6 Port 2"]
        PORT2,
        #[doc = "5 - 0xFFEA ADC10"]
        ADC10,
        #[doc = "6 - 0xFFEC USCI A0/B0 Transmit"]
        USCIAB0TX,
        #[doc = "7 - 0xFFEE USCI A0/B0 Receive"]
        USCIAB0RX,
        #[doc = "8 - 0xFFF0 Timer0)A CC1, TA0"]
        TIMER0_A1,
        #[doc = "9 - 0xFFF2 Timer0_A CC0"]
        TIMER0_A0,
        #[doc = "10 - 0xFFF4 Watchdog Timer"]
        WDT,
        #[doc = "11 - 0xFFF6 Comparator A"]
        COMPARATORA,
        #[doc = "12 - 0xFFF8 Timer1_A CC1-4, TA1"]
        TIMER1_A1,
        #[doc = "13 - 0xFFFA Timer1_A CC0"]
        TIMER1_A0,
        #[doc = "14 - 0xFFFC Non-maskable"]
        NMI,
    }
    unsafe impl Nr for Interrupt {
        #[inline(always)]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::TRAPINT => 0,
                Interrupt::PORT1 => 2,
                Interrupt::PORT2 => 3,
                Interrupt::ADC10 => 5,
                Interrupt::USCIAB0TX => 6,
                Interrupt::USCIAB0RX => 7,
                Interrupt::TIMER0_A1 => 8,
                Interrupt::TIMER0_A0 => 9,
                Interrupt::WDT => 10,
                Interrupt::COMPARATORA => 11,
                Interrupt::TIMER1_A1 => 12,
                Interrupt::TIMER1_A0 => 13,
                Interrupt::NMI => 14,
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ident = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "msp430-interrupt" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "msp430-interrupt" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
#[doc = "Flash"]
pub const FLASH: Peripheral<FLASH> = unsafe { Peripheral::new(296) };
#[doc = "Flash"]
pub mod flash {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - FLASH Control 1"]
        pub fctl1: FCTL1,
        #[doc = "0x02 - FLASH Control 2"]
        pub fctl2: FCTL2,
        #[doc = "0x04 - FLASH Control 3"]
        pub fctl3: FCTL3,
    }
    #[doc = "FLASH Control 1"]
    pub struct FCTL1 {
        register: VolatileCell<u16>,
    }
    #[doc = "FLASH Control 1"]
    pub mod fctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::FCTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ERASE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERASER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ERASER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ERASER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ERASER {
                match value {
                    i => ERASER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MERAS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MERASR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MERASR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MERASR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MERASR {
                match value {
                    i => MERASR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WRT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WRTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WRTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WRTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WRTR {
                match value {
                    i => WRTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `BLKWRT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BLKWRTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl BLKWRTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BLKWRTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BLKWRTR {
                match value {
                    i => BLKWRTR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `ERASE`"]
        pub enum ERASEW { }
        impl ERASEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERASEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERASEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERASEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MERAS`"]
        pub enum MERASW { }
        impl MERASW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MERASW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MERASW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MERASW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WRT`"]
        pub enum WRTW { }
        impl WRTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WRTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BLKWRT`"]
        pub enum BLKWRTW { }
        impl BLKWRTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLKWRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLKWRTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BLKWRTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Enable bit for Flash segment erase"]
            #[inline(always)]
            pub fn erase(&self) -> ERASER {
                ERASER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - Enable bit for Flash mass erase"]
            #[inline(always)]
            pub fn meras(&self) -> MERASR {
                MERASR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - Enable bit for Flash write"]
            #[inline(always)]
            pub fn wrt(&self) -> WRTR {
                WRTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - Enable bit for Flash segment write"]
            #[inline(always)]
            pub fn blkwrt(&self) -> BLKWRTR {
                BLKWRTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable bit for Flash segment erase"]
            #[inline(always)]
            pub fn erase(&mut self) -> _ERASEW {
                _ERASEW { w: self }
            }
            #[doc = "Bit 2 - Enable bit for Flash mass erase"]
            #[inline(always)]
            pub fn meras(&mut self) -> _MERASW {
                _MERASW { w: self }
            }
            #[doc = "Bit 6 - Enable bit for Flash write"]
            #[inline(always)]
            pub fn wrt(&mut self) -> _WRTW {
                _WRTW { w: self }
            }
            #[doc = "Bit 7 - Enable bit for Flash segment write"]
            #[inline(always)]
            pub fn blkwrt(&mut self) -> _BLKWRTW {
                _BLKWRTW { w: self }
            }
        }
    }
    #[doc = "FLASH Control 2"]
    pub struct FCTL2 {
        register: VolatileCell<u16>,
    }
    #[doc = "FLASH Control 2"]
    pub mod fctl2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::FCTL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN0R {
                match value {
                    i => FN0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN1R {
                match value {
                    i => FN1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN2R {
                match value {
                    i => FN2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN3R {
                match value {
                    i => FN3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN4R {
                match value {
                    i => FN4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FN5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FN5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FN5R {
                match value {
                    i => FN5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FSSELR {
            #[doc = "Flash clock select: 0 - ACLK"]
            FSSEL_0,
            #[doc = "Flash clock select: 1 - MCLK"]
            FSSEL_1,
            #[doc = "Flash clock select: 2 - SMCLK"]
            FSSEL_2,
            #[doc = "Flash clock select: 3 - SMCLK"]
            FSSEL_3,
        }
        impl FSSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FSSELR::FSSEL_0 => 0,
                    FSSELR::FSSEL_1 => 1,
                    FSSELR::FSSEL_2 => 2,
                    FSSELR::FSSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FSSELR {
                match value {
                    0 => FSSELR::FSSEL_0,
                    1 => FSSELR::FSSEL_1,
                    2 => FSSELR::FSSEL_2,
                    3 => FSSELR::FSSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FSSEL_0`"]
            #[inline(always)]
            pub fn is_fssel_0(&self) -> bool {
                *self == FSSELR::FSSEL_0
            }
            #[doc = "Checks if the value of the field is `FSSEL_1`"]
            #[inline(always)]
            pub fn is_fssel_1(&self) -> bool {
                *self == FSSELR::FSSEL_1
            }
            #[doc = "Checks if the value of the field is `FSSEL_2`"]
            #[inline(always)]
            pub fn is_fssel_2(&self) -> bool {
                *self == FSSELR::FSSEL_2
            }
            #[doc = "Checks if the value of the field is `FSSEL_3`"]
            #[inline(always)]
            pub fn is_fssel_3(&self) -> bool {
                *self == FSSELR::FSSEL_3
            }
        }
        #[doc = "Values that can be written to the field `FN0`"]
        pub enum FN0W { }
        impl FN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FN1`"]
        pub enum FN1W { }
        impl FN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FN2`"]
        pub enum FN2W { }
        impl FN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FN3`"]
        pub enum FN3W { }
        impl FN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FN4`"]
        pub enum FN4W { }
        impl FN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FN5`"]
        pub enum FN5W { }
        impl FN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FSSEL`"]
        pub enum FSSELW {
            #[doc = "Flash clock select: 0 - ACLK"]
            FSSEL_0,
            #[doc = "Flash clock select: 1 - MCLK"]
            FSSEL_1,
            #[doc = "Flash clock select: 2 - SMCLK"]
            FSSEL_2,
            #[doc = "Flash clock select: 3 - SMCLK"]
            FSSEL_3,
        }
        impl FSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FSSELW::FSSEL_0 => 0,
                    FSSELW::FSSEL_1 => 1,
                    FSSELW::FSSEL_2 => 2,
                    FSSELW::FSSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FSSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Flash clock select: 0 - ACLK"]
            #[inline(always)]
            pub fn fssel_0(self) -> &'a mut W {
                self.variant(FSSELW::FSSEL_0)
            }
            #[doc = "Flash clock select: 1 - MCLK"]
            #[inline(always)]
            pub fn fssel_1(self) -> &'a mut W {
                self.variant(FSSELW::FSSEL_1)
            }
            #[doc = "Flash clock select: 2 - SMCLK"]
            #[inline(always)]
            pub fn fssel_2(self) -> &'a mut W {
                self.variant(FSSELW::FSSEL_2)
            }
            #[doc = "Flash clock select: 3 - SMCLK"]
            #[inline(always)]
            pub fn fssel_3(self) -> &'a mut W {
                self.variant(FSSELW::FSSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
            #[inline(always)]
            pub fn fn0(&self) -> FN0R {
                FN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
            #[inline(always)]
            pub fn fn1(&self) -> FN1R {
                FN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - FN2"]
            #[inline(always)]
            pub fn fn2(&self) -> FN2R {
                FN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - FN3"]
            #[inline(always)]
            pub fn fn3(&self) -> FN3R {
                FN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - FN4"]
            #[inline(always)]
            pub fn fn4(&self) -> FN4R {
                FN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - FN5"]
            #[inline(always)]
            pub fn fn5(&self) -> FN5R {
                FN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 6:7 - Flash clock select 0 */ /* to distinguish from USART SSELx"]
            #[inline(always)]
            pub fn fssel(&self) -> FSSELR {
                FSSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
            #[inline(always)]
            pub fn fn0(&mut self) -> _FN0W {
                _FN0W { w: self }
            }
            #[doc = "Bit 1 - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
            #[inline(always)]
            pub fn fn1(&mut self) -> _FN1W {
                _FN1W { w: self }
            }
            #[doc = "Bit 2 - FN2"]
            #[inline(always)]
            pub fn fn2(&mut self) -> _FN2W {
                _FN2W { w: self }
            }
            #[doc = "Bit 3 - FN3"]
            #[inline(always)]
            pub fn fn3(&mut self) -> _FN3W {
                _FN3W { w: self }
            }
            #[doc = "Bit 4 - FN4"]
            #[inline(always)]
            pub fn fn4(&mut self) -> _FN4W {
                _FN4W { w: self }
            }
            #[doc = "Bit 5 - FN5"]
            #[inline(always)]
            pub fn fn5(&mut self) -> _FN5W {
                _FN5W { w: self }
            }
            #[doc = "Bits 6:7 - Flash clock select 0 */ /* to distinguish from USART SSELx"]
            #[inline(always)]
            pub fn fssel(&mut self) -> _FSSELW {
                _FSSELW { w: self }
            }
        }
    }
    #[doc = "FLASH Control 3"]
    pub struct FCTL3 {
        register: VolatileCell<u16>,
    }
    #[doc = "FLASH Control 3"]
    pub mod fctl3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::FCTL3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl BUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BUSYR {
                match value {
                    i => BUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `KEYV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEYVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl KEYVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    KEYVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> KEYVR {
                match value {
                    i => KEYVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ACCVIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACCVIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ACCVIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACCVIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACCVIFGR {
                match value {
                    i => ACCVIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WAIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WAITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WAITR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WAITR {
                match value {
                    i => WAITR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `LOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl LOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOCKR {
                match value {
                    i => LOCKR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `EMEX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMEXR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl EMEXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EMEXR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EMEXR {
                match value {
                    i => EMEXR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `LOCKA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKAR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl LOCKAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKAR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOCKAR {
                match value {
                    i => LOCKAR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `FAIL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FAILR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl FAILR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FAILR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FAILR {
                match value {
                    i => FAILR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `BUSY`"]
        pub enum BUSYW { }
        impl BUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `KEYV`"]
        pub enum KEYVW { }
        impl KEYVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEYVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEYVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: KEYVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACCVIFG`"]
        pub enum ACCVIFGW { }
        impl ACCVIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCVIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCVIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACCVIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAIT`"]
        pub enum WAITW { }
        impl WAITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOCK`"]
        pub enum LOCKW { }
        impl LOCKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LOCKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMEX`"]
        pub enum EMEXW { }
        impl EMEXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMEXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMEXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EMEXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOCKA`"]
        pub enum LOCKAW { }
        impl LOCKAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LOCKAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FAIL`"]
        pub enum FAILW { }
        impl FAILW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAILW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAILW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FAILW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Flash busy: 1"]
            #[inline(always)]
            pub fn busy(&self) -> BUSYR {
                BUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Flash Key violation flag"]
            #[inline(always)]
            pub fn keyv(&self) -> KEYVR {
                KEYVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - Flash Access violation flag"]
            #[inline(always)]
            pub fn accvifg(&self) -> ACCVIFGR {
                ACCVIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Wait flag for segment write"]
            #[inline(always)]
            pub fn wait(&self) -> WAITR {
                WAITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)"]
            #[inline(always)]
            pub fn lock(&self) -> LOCKR {
                LOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - Flash Emergency Exit"]
            #[inline(always)]
            pub fn emex(&self) -> EMEXR {
                EMEXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
            #[inline(always)]
            pub fn locka(&self) -> LOCKAR {
                LOCKAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - Last Program or Erase failed"]
            #[inline(always)]
            pub fn fail(&self) -> FAILR {
                FAILR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Flash busy: 1"]
            #[inline(always)]
            pub fn busy(&mut self) -> _BUSYW {
                _BUSYW { w: self }
            }
            #[doc = "Bit 1 - Flash Key violation flag"]
            #[inline(always)]
            pub fn keyv(&mut self) -> _KEYVW {
                _KEYVW { w: self }
            }
            #[doc = "Bit 2 - Flash Access violation flag"]
            #[inline(always)]
            pub fn accvifg(&mut self) -> _ACCVIFGW {
                _ACCVIFGW { w: self }
            }
            #[doc = "Bit 3 - Wait flag for segment write"]
            #[inline(always)]
            pub fn wait(&mut self) -> _WAITW {
                _WAITW { w: self }
            }
            #[doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)"]
            #[inline(always)]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
            #[doc = "Bit 5 - Flash Emergency Exit"]
            #[inline(always)]
            pub fn emex(&mut self) -> _EMEXW {
                _EMEXW { w: self }
            }
            #[doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
            #[inline(always)]
            pub fn locka(&mut self) -> _LOCKAW {
                _LOCKAW { w: self }
            }
            #[doc = "Bit 7 - Last Program or Erase failed"]
            #[inline(always)]
            pub fn fail(&mut self) -> _FAILW {
                _FAILW { w: self }
            }
        }
    }
}
#[doc = "Flash"]
pub struct FLASH {
    register_block: flash::RegisterBlock,
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    fn deref(&self) -> &flash::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USCI_A0 UART Mode"]
pub const USCI_A0_UART_MODE: Peripheral<USCI_A0_UART_MODE> =
    unsafe { Peripheral::new(92) };
#[doc = "USCI_A0 UART Mode"]
pub mod usci_a0_uart_mode {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1usize],
        #[doc = "0x01 - USCI A0 LIN Control"]
        pub uca0abctl: UCA0ABCTL,
        #[doc = "0x02 - USCI A0 IrDA Transmit Control"]
        pub uca0irtctl: UCA0IRTCTL,
        #[doc = "0x03 - USCI A0 IrDA Receive Control"]
        pub uca0irrctl: UCA0IRRCTL,
        #[doc = "0x04 - USCI A0 Control Register 0"]
        pub uca0ctl0: UCA0CTL0,
        #[doc = "0x05 - USCI A0 Control Register 1"]
        pub uca0ctl1: UCA0CTL1,
        #[doc = "0x06 - USCI A0 Baud Rate 0"]
        pub uca0br0: UCA0BR0,
        #[doc = "0x07 - USCI A0 Baud Rate 1"]
        pub uca0br1: UCA0BR1,
        #[doc = "0x08 - USCI A0 Modulation Control"]
        pub uca0mctl: UCA0MCTL,
        #[doc = "0x09 - USCI A0 Status Register"]
        pub uca0stat: UCA0STAT,
        #[doc = "0x0a - USCI A0 Receive Buffer"]
        pub uca0rxbuf: UCA0RXBUF,
        #[doc = "0x0b - USCI A0 Transmit Buffer"]
        pub uca0txbuf: UCA0TXBUF,
    }
    #[doc = "USCI A0 LIN Control"]
    pub struct UCA0ABCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 LIN Control"]
    pub mod uca0abctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0ABCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCABDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCABDENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCABDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCABDENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCABDENR {
                match value {
                    i => UCABDENR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCBTOE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBTOER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBTOER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBTOER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBTOER {
                match value {
                    i => UCBTOER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSTOE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSTOER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSTOER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSTOER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSTOER {
                match value {
                    i => UCSTOER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCDELIM0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCDELIM0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCDELIM0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCDELIM0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCDELIM0R {
                match value {
                    i => UCDELIM0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCDELIM1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCDELIM1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCDELIM1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCDELIM1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCDELIM1R {
                match value {
                    i => UCDELIM1R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCABDEN`"]
        pub enum UCABDENW { }
        impl UCABDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCABDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCABDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCABDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBTOE`"]
        pub enum UCBTOEW { }
        impl UCBTOEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBTOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBTOEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBTOEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSTOE`"]
        pub enum UCSTOEW { }
        impl UCSTOEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSTOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSTOEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSTOEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCDELIM0`"]
        pub enum UCDELIM0W { }
        impl UCDELIM0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCDELIM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCDELIM0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCDELIM0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCDELIM1`"]
        pub enum UCDELIM1W { }
        impl UCDELIM1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCDELIM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCDELIM1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCDELIM1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Auto Baud Rate detect enable"]
            #[inline(always)]
            pub fn ucabden(&self) -> UCABDENR {
                UCABDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Break Timeout error"]
            #[inline(always)]
            pub fn ucbtoe(&self) -> UCBTOER {
                UCBTOER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Sync-Field Timeout error"]
            #[inline(always)]
            pub fn ucstoe(&self) -> UCSTOER {
                UCSTOER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Break Sync Delimiter 0"]
            #[inline(always)]
            pub fn ucdelim0(&self) -> UCDELIM0R {
                UCDELIM0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Break Sync Delimiter 1"]
            #[inline(always)]
            pub fn ucdelim1(&self) -> UCDELIM1R {
                UCDELIM1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Auto Baud Rate detect enable"]
            #[inline(always)]
            pub fn ucabden(&mut self) -> _UCABDENW {
                _UCABDENW { w: self }
            }
            #[doc = "Bit 2 - Break Timeout error"]
            #[inline(always)]
            pub fn ucbtoe(&mut self) -> _UCBTOEW {
                _UCBTOEW { w: self }
            }
            #[doc = "Bit 3 - Sync-Field Timeout error"]
            #[inline(always)]
            pub fn ucstoe(&mut self) -> _UCSTOEW {
                _UCSTOEW { w: self }
            }
            #[doc = "Bit 4 - Break Sync Delimiter 0"]
            #[inline(always)]
            pub fn ucdelim0(&mut self) -> _UCDELIM0W {
                _UCDELIM0W { w: self }
            }
            #[doc = "Bit 5 - Break Sync Delimiter 1"]
            #[inline(always)]
            pub fn ucdelim1(&mut self) -> _UCDELIM1W {
                _UCDELIM1W { w: self }
            }
        }
    }
    #[doc = "USCI A0 IrDA Transmit Control"]
    pub struct UCA0IRTCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 IrDA Transmit Control"]
    pub mod uca0irtctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0IRTCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCIREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRENR {
                match value {
                    i => UCIRENR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXCLK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXCLKR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXCLKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXCLKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXCLKR {
                match value {
                    i => UCIRTXCLKR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL0R {
                match value {
                    i => UCIRTXPL0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL1R {
                match value {
                    i => UCIRTXPL1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL2R {
                match value {
                    i => UCIRTXPL2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL3R {
                match value {
                    i => UCIRTXPL3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL4R {
                match value {
                    i => UCIRTXPL4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRTXPL5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRTXPL5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRTXPL5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRTXPL5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRTXPL5R {
                match value {
                    i => UCIRTXPL5R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCIREN`"]
        pub enum UCIRENW { }
        impl UCIRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXCLK`"]
        pub enum UCIRTXCLKW { }
        impl UCIRTXCLKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXCLKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXCLKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL0`"]
        pub enum UCIRTXPL0W { }
        impl UCIRTXPL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL1`"]
        pub enum UCIRTXPL1W { }
        impl UCIRTXPL1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL2`"]
        pub enum UCIRTXPL2W { }
        impl UCIRTXPL2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL3`"]
        pub enum UCIRTXPL3W { }
        impl UCIRTXPL3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL4`"]
        pub enum UCIRTXPL4W { }
        impl UCIRTXPL4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRTXPL5`"]
        pub enum UCIRTXPL5W { }
        impl UCIRTXPL5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRTXPL5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRTXPL5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRTXPL5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - IRDA Encoder/Decoder enable"]
            #[inline(always)]
            pub fn uciren(&self) -> UCIRENR {
                UCIRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - IRDA Transmit Pulse Clock Select"]
            #[inline(always)]
            pub fn ucirtxclk(&self) -> UCIRTXCLKR {
                UCIRTXCLKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - IRDA Transmit Pulse Length 0"]
            #[inline(always)]
            pub fn ucirtxpl0(&self) -> UCIRTXPL0R {
                UCIRTXPL0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - IRDA Transmit Pulse Length 1"]
            #[inline(always)]
            pub fn ucirtxpl1(&self) -> UCIRTXPL1R {
                UCIRTXPL1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - IRDA Transmit Pulse Length 2"]
            #[inline(always)]
            pub fn ucirtxpl2(&self) -> UCIRTXPL2R {
                UCIRTXPL2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - IRDA Transmit Pulse Length 3"]
            #[inline(always)]
            pub fn ucirtxpl3(&self) -> UCIRTXPL3R {
                UCIRTXPL3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - IRDA Transmit Pulse Length 4"]
            #[inline(always)]
            pub fn ucirtxpl4(&self) -> UCIRTXPL4R {
                UCIRTXPL4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - IRDA Transmit Pulse Length 5"]
            #[inline(always)]
            pub fn ucirtxpl5(&self) -> UCIRTXPL5R {
                UCIRTXPL5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRDA Encoder/Decoder enable"]
            #[inline(always)]
            pub fn uciren(&mut self) -> _UCIRENW {
                _UCIRENW { w: self }
            }
            #[doc = "Bit 1 - IRDA Transmit Pulse Clock Select"]
            #[inline(always)]
            pub fn ucirtxclk(&mut self) -> _UCIRTXCLKW {
                _UCIRTXCLKW { w: self }
            }
            #[doc = "Bit 2 - IRDA Transmit Pulse Length 0"]
            #[inline(always)]
            pub fn ucirtxpl0(&mut self) -> _UCIRTXPL0W {
                _UCIRTXPL0W { w: self }
            }
            #[doc = "Bit 3 - IRDA Transmit Pulse Length 1"]
            #[inline(always)]
            pub fn ucirtxpl1(&mut self) -> _UCIRTXPL1W {
                _UCIRTXPL1W { w: self }
            }
            #[doc = "Bit 4 - IRDA Transmit Pulse Length 2"]
            #[inline(always)]
            pub fn ucirtxpl2(&mut self) -> _UCIRTXPL2W {
                _UCIRTXPL2W { w: self }
            }
            #[doc = "Bit 5 - IRDA Transmit Pulse Length 3"]
            #[inline(always)]
            pub fn ucirtxpl3(&mut self) -> _UCIRTXPL3W {
                _UCIRTXPL3W { w: self }
            }
            #[doc = "Bit 6 - IRDA Transmit Pulse Length 4"]
            #[inline(always)]
            pub fn ucirtxpl4(&mut self) -> _UCIRTXPL4W {
                _UCIRTXPL4W { w: self }
            }
            #[doc = "Bit 7 - IRDA Transmit Pulse Length 5"]
            #[inline(always)]
            pub fn ucirtxpl5(&mut self) -> _UCIRTXPL5W {
                _UCIRTXPL5W { w: self }
            }
        }
    }
    #[doc = "USCI A0 IrDA Receive Control"]
    pub struct UCA0IRRCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 IrDA Receive Control"]
    pub mod uca0irrctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0IRRCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCIRRXFE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFER {
                match value {
                    i => UCIRRXFER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXPL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXPLR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXPLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXPLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXPLR {
                match value {
                    i => UCIRRXPLR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL0R {
                match value {
                    i => UCIRRXFL0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL1R {
                match value {
                    i => UCIRRXFL1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL2R {
                match value {
                    i => UCIRRXFL2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL3R {
                match value {
                    i => UCIRRXFL3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL4R {
                match value {
                    i => UCIRRXFL4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCIRRXFL5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCIRRXFL5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCIRRXFL5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCIRRXFL5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCIRRXFL5R {
                match value {
                    i => UCIRRXFL5R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFE`"]
        pub enum UCIRRXFEW { }
        impl UCIRRXFEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXPL`"]
        pub enum UCIRRXPLW { }
        impl UCIRRXPLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXPLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXPLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL0`"]
        pub enum UCIRRXFL0W { }
        impl UCIRRXFL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL1`"]
        pub enum UCIRRXFL1W { }
        impl UCIRRXFL1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL2`"]
        pub enum UCIRRXFL2W { }
        impl UCIRRXFL2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL3`"]
        pub enum UCIRRXFL3W { }
        impl UCIRRXFL3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL4`"]
        pub enum UCIRRXFL4W { }
        impl UCIRRXFL4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCIRRXFL5`"]
        pub enum UCIRRXFL5W { }
        impl UCIRRXFL5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCIRRXFL5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCIRRXFL5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCIRRXFL5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - IRDA Receive Filter enable"]
            #[inline(always)]
            pub fn ucirrxfe(&self) -> UCIRRXFER {
                UCIRRXFER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - IRDA Receive Input Polarity"]
            #[inline(always)]
            pub fn ucirrxpl(&self) -> UCIRRXPLR {
                UCIRRXPLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - IRDA Receive Filter Length 0"]
            #[inline(always)]
            pub fn ucirrxfl0(&self) -> UCIRRXFL0R {
                UCIRRXFL0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - IRDA Receive Filter Length 1"]
            #[inline(always)]
            pub fn ucirrxfl1(&self) -> UCIRRXFL1R {
                UCIRRXFL1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - IRDA Receive Filter Length 2"]
            #[inline(always)]
            pub fn ucirrxfl2(&self) -> UCIRRXFL2R {
                UCIRRXFL2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - IRDA Receive Filter Length 3"]
            #[inline(always)]
            pub fn ucirrxfl3(&self) -> UCIRRXFL3R {
                UCIRRXFL3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - IRDA Receive Filter Length 4"]
            #[inline(always)]
            pub fn ucirrxfl4(&self) -> UCIRRXFL4R {
                UCIRRXFL4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - IRDA Receive Filter Length 5"]
            #[inline(always)]
            pub fn ucirrxfl5(&self) -> UCIRRXFL5R {
                UCIRRXFL5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRDA Receive Filter enable"]
            #[inline(always)]
            pub fn ucirrxfe(&mut self) -> _UCIRRXFEW {
                _UCIRRXFEW { w: self }
            }
            #[doc = "Bit 1 - IRDA Receive Input Polarity"]
            #[inline(always)]
            pub fn ucirrxpl(&mut self) -> _UCIRRXPLW {
                _UCIRRXPLW { w: self }
            }
            #[doc = "Bit 2 - IRDA Receive Filter Length 0"]
            #[inline(always)]
            pub fn ucirrxfl0(&mut self) -> _UCIRRXFL0W {
                _UCIRRXFL0W { w: self }
            }
            #[doc = "Bit 3 - IRDA Receive Filter Length 1"]
            #[inline(always)]
            pub fn ucirrxfl1(&mut self) -> _UCIRRXFL1W {
                _UCIRRXFL1W { w: self }
            }
            #[doc = "Bit 4 - IRDA Receive Filter Length 2"]
            #[inline(always)]
            pub fn ucirrxfl2(&mut self) -> _UCIRRXFL2W {
                _UCIRRXFL2W { w: self }
            }
            #[doc = "Bit 5 - IRDA Receive Filter Length 3"]
            #[inline(always)]
            pub fn ucirrxfl3(&mut self) -> _UCIRRXFL3W {
                _UCIRRXFL3W { w: self }
            }
            #[doc = "Bit 6 - IRDA Receive Filter Length 4"]
            #[inline(always)]
            pub fn ucirrxfl4(&mut self) -> _UCIRRXFL4W {
                _UCIRRXFL4W { w: self }
            }
            #[doc = "Bit 7 - IRDA Receive Filter Length 5"]
            #[inline(always)]
            pub fn ucirrxfl5(&mut self) -> _UCIRRXFL5W {
                _UCIRRXFL5W { w: self }
            }
        }
    }
    #[doc = "USCI A0 Control Register 0"]
    pub struct UCA0CTL0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Control Register 0"]
    pub mod uca0ctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0CTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSYNCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSYNCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSYNCR {
                match value {
                    i => UCSYNCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMODER {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCMODER::UCMODE_0 => 0,
                    UCMODER::UCMODE_1 => 1,
                    UCMODER::UCMODE_2 => 2,
                    UCMODER::UCMODE_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCMODER {
                match value {
                    0 => UCMODER::UCMODE_0,
                    1 => UCMODER::UCMODE_1,
                    2 => UCMODER::UCMODE_2,
                    3 => UCMODER::UCMODE_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCMODE_0`"]
            #[inline(always)]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UCMODER::UCMODE_0
            }
            #[doc = "Checks if the value of the field is `UCMODE_1`"]
            #[inline(always)]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UCMODER::UCMODE_1
            }
            #[doc = "Checks if the value of the field is `UCMODE_2`"]
            #[inline(always)]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UCMODER::UCMODE_2
            }
            #[doc = "Checks if the value of the field is `UCMODE_3`"]
            #[inline(always)]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UCMODER::UCMODE_3
            }
        }
        #[doc = "Possible values of the field `UCSPB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSPBR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSPBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSPBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSPBR {
                match value {
                    i => UCSPBR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UC7BIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UC7BITR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UC7BITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UC7BITR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UC7BITR {
                match value {
                    i => UC7BITR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMSB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSBR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSBR {
                match value {
                    i => UCMSBR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCPAR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCPARR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCPARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCPARR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCPARR {
                match value {
                    i => UCPARR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCPEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCPENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCPENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCPENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCPENR {
                match value {
                    i => UCPENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCSYNC`"]
        pub enum UCSYNCW { }
        impl UCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSYNCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMODE`"]
        pub enum UCMODEW {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCMODEW::UCMODE_0 => 0,
                    UCMODEW::UCMODE_1 => 1,
                    UCMODEW::UCMODE_2 => 2,
                    UCMODEW::UCMODE_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Sync. Mode: USCI Mode: 0"]
            #[inline(always)]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_0)
            }
            #[doc = "Sync. Mode: USCI Mode: 1"]
            #[inline(always)]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_1)
            }
            #[doc = "Sync. Mode: USCI Mode: 2"]
            #[inline(always)]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_2)
            }
            #[doc = "Sync. Mode: USCI Mode: 3"]
            #[inline(always)]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSPB`"]
        pub enum UCSPBW { }
        impl UCSPBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSPBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSPBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSPBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UC7BIT`"]
        pub enum UC7BITW { }
        impl UC7BITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UC7BITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UC7BITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UC7BITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMSB`"]
        pub enum UCMSBW { }
        impl UCMSBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCPAR`"]
        pub enum UCPARW { }
        impl UCPARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCPARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCPARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCPARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCPEN`"]
        pub enum UCPENW { }
        impl UCPENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCPENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCPENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&self) -> UCSYNCR {
                UCSYNCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 1:2 - Async. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&self) -> UCMODER {
                UCMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Async. Mode: Stop Bits 0:one / 1: two"]
            #[inline(always)]
            pub fn ucspb(&self) -> UCSPBR {
                UCSPBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Async. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&self) -> UC7BITR {
                UC7BITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Async. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&self) -> UCMSBR {
                UCMSBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - Async. Mode: Parity 0:odd / 1:even"]
            #[inline(always)]
            pub fn ucpar(&self) -> UCPARR {
                UCPARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Async. Mode: Parity enable"]
            #[inline(always)]
            pub fn ucpen(&self) -> UCPENR {
                UCPENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&mut self) -> _UCSYNCW {
                _UCSYNCW { w: self }
            }
            #[doc = "Bits 1:2 - Async. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&mut self) -> _UCMODEW {
                _UCMODEW { w: self }
            }
            #[doc = "Bit 3 - Async. Mode: Stop Bits 0:one / 1: two"]
            #[inline(always)]
            pub fn ucspb(&mut self) -> _UCSPBW {
                _UCSPBW { w: self }
            }
            #[doc = "Bit 4 - Async. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&mut self) -> _UC7BITW {
                _UC7BITW { w: self }
            }
            #[doc = "Bit 5 - Async. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&mut self) -> _UCMSBW {
                _UCMSBW { w: self }
            }
            #[doc = "Bit 6 - Async. Mode: Parity 0:odd / 1:even"]
            #[inline(always)]
            pub fn ucpar(&mut self) -> _UCPARW {
                _UCPARW { w: self }
            }
            #[doc = "Bit 7 - Async. Mode: Parity enable"]
            #[inline(always)]
            pub fn ucpen(&mut self) -> _UCPENW {
                _UCPENW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Control Register 1"]
    pub struct UCA0CTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Control Register 1"]
    pub mod uca0ctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0CTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSWRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSWRSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSWRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSWRSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSWRSTR {
                match value {
                    i => UCSWRSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTXBRK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTXBRKR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTXBRKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTXBRKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTXBRKR {
                match value {
                    i => UCTXBRKR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTXADDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTXADDRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTXADDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTXADDRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTXADDRR {
                match value {
                    i => UCTXADDRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCDORM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCDORMR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCDORMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCDORMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCDORMR {
                match value {
                    i => UCDORMR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCBRKIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBRKIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBRKIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBRKIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBRKIER {
                match value {
                    i => UCBRKIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCRXEIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCRXEIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCRXEIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCRXEIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCRXEIER {
                match value {
                    i => UCRXEIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSSELR {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCSSELR::UCSSEL_0 => 0,
                    UCSSELR::UCSSEL_1 => 1,
                    UCSSELR::UCSSEL_2 => 2,
                    UCSSELR::UCSSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCSSELR {
                match value {
                    0 => UCSSELR::UCSSEL_0,
                    1 => UCSSELR::UCSSEL_1,
                    2 => UCSSELR::UCSSEL_2,
                    3 => UCSSELR::UCSSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCSSEL_0`"]
            #[inline(always)]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UCSSELR::UCSSEL_0
            }
            #[doc = "Checks if the value of the field is `UCSSEL_1`"]
            #[inline(always)]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UCSSELR::UCSSEL_1
            }
            #[doc = "Checks if the value of the field is `UCSSEL_2`"]
            #[inline(always)]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UCSSELR::UCSSEL_2
            }
            #[doc = "Checks if the value of the field is `UCSSEL_3`"]
            #[inline(always)]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UCSSELR::UCSSEL_3
            }
        }
        #[doc = "Values that can be written to the field `UCSWRST`"]
        pub enum UCSWRSTW { }
        impl UCSWRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSWRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSWRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTXBRK`"]
        pub enum UCTXBRKW { }
        impl UCTXBRKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTXBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTXBRKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTXBRKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTXADDR`"]
        pub enum UCTXADDRW { }
        impl UCTXADDRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTXADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTXADDRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTXADDRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCDORM`"]
        pub enum UCDORMW { }
        impl UCDORMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCDORMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCDORMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCDORMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBRKIE`"]
        pub enum UCBRKIEW { }
        impl UCBRKIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBRKIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBRKIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBRKIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCRXEIE`"]
        pub enum UCRXEIEW { }
        impl UCRXEIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCRXEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCRXEIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCRXEIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSSEL`"]
        pub enum UCSSELW {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCSSELW::UCSSEL_0 => 0,
                    UCSSELW::UCSSEL_1 => 1,
                    UCSSELW::UCSSEL_2 => 2,
                    UCSSELW::UCSSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI 0 Clock Source: 0"]
            #[inline(always)]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_0)
            }
            #[doc = "USCI 0 Clock Source: 1"]
            #[inline(always)]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_1)
            }
            #[doc = "USCI 0 Clock Source: 2"]
            #[inline(always)]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_2)
            }
            #[doc = "USCI 0 Clock Source: 3"]
            #[inline(always)]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&self) -> UCSWRSTR {
                UCSWRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Send next Data as Break"]
            #[inline(always)]
            pub fn uctxbrk(&self) -> UCTXBRKR {
                UCTXBRKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Send next Data as Address"]
            #[inline(always)]
            pub fn uctxaddr(&self) -> UCTXADDRR {
                UCTXADDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Dormant (Sleep) Mode"]
            #[inline(always)]
            pub fn ucdorm(&self) -> UCDORMR {
                UCDORMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Break interrupt enable"]
            #[inline(always)]
            pub fn ucbrkie(&self) -> UCBRKIER {
                UCBRKIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - RX Error interrupt enable"]
            #[inline(always)]
            pub fn ucrxeie(&self) -> UCRXEIER {
                UCRXEIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 6:7 - USCI 0 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&self) -> UCSSELR {
                UCSSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&mut self) -> _UCSWRSTW {
                _UCSWRSTW { w: self }
            }
            #[doc = "Bit 1 - Send next Data as Break"]
            #[inline(always)]
            pub fn uctxbrk(&mut self) -> _UCTXBRKW {
                _UCTXBRKW { w: self }
            }
            #[doc = "Bit 2 - Send next Data as Address"]
            #[inline(always)]
            pub fn uctxaddr(&mut self) -> _UCTXADDRW {
                _UCTXADDRW { w: self }
            }
            #[doc = "Bit 3 - Dormant (Sleep) Mode"]
            #[inline(always)]
            pub fn ucdorm(&mut self) -> _UCDORMW {
                _UCDORMW { w: self }
            }
            #[doc = "Bit 4 - Break interrupt enable"]
            #[inline(always)]
            pub fn ucbrkie(&mut self) -> _UCBRKIEW {
                _UCBRKIEW { w: self }
            }
            #[doc = "Bit 5 - RX Error interrupt enable"]
            #[inline(always)]
            pub fn ucrxeie(&mut self) -> _UCRXEIEW {
                _UCRXEIEW { w: self }
            }
            #[doc = "Bits 6:7 - USCI 0 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&mut self) -> _UCSSELW {
                _UCSSELW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Baud Rate 0"]
    pub struct UCA0BR0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Baud Rate 0"]
    pub mod uca0br0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0BR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Baud Rate 1"]
    pub struct UCA0BR1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Baud Rate 1"]
    pub mod uca0br1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0BR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Modulation Control"]
    pub struct UCA0MCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Modulation Control"]
    pub mod uca0mctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0MCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCOS16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOS16R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOS16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOS16R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOS16R {
                match value {
                    i => UCOS16R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCBRS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBRSR {
            #[doc = "USCI Second Stage Modulation: 0"]
            UCBRS_0,
            #[doc = "USCI Second Stage Modulation: 1"]
            UCBRS_1,
            #[doc = "USCI Second Stage Modulation: 2"]
            UCBRS_2,
            #[doc = "USCI Second Stage Modulation: 3"]
            UCBRS_3,
            #[doc = "USCI Second Stage Modulation: 4"]
            UCBRS_4,
            #[doc = "USCI Second Stage Modulation: 5"]
            UCBRS_5,
            #[doc = "USCI Second Stage Modulation: 6"]
            UCBRS_6,
            #[doc = "USCI Second Stage Modulation: 7"]
            UCBRS_7,
        }
        impl UCBRSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCBRSR::UCBRS_0 => 0,
                    UCBRSR::UCBRS_1 => 1,
                    UCBRSR::UCBRS_2 => 2,
                    UCBRSR::UCBRS_3 => 3,
                    UCBRSR::UCBRS_4 => 4,
                    UCBRSR::UCBRS_5 => 5,
                    UCBRSR::UCBRS_6 => 6,
                    UCBRSR::UCBRS_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCBRSR {
                match value {
                    0 => UCBRSR::UCBRS_0,
                    1 => UCBRSR::UCBRS_1,
                    2 => UCBRSR::UCBRS_2,
                    3 => UCBRSR::UCBRS_3,
                    4 => UCBRSR::UCBRS_4,
                    5 => UCBRSR::UCBRS_5,
                    6 => UCBRSR::UCBRS_6,
                    7 => UCBRSR::UCBRS_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCBRS_0`"]
            #[inline(always)]
            pub fn is_ucbrs_0(&self) -> bool {
                *self == UCBRSR::UCBRS_0
            }
            #[doc = "Checks if the value of the field is `UCBRS_1`"]
            #[inline(always)]
            pub fn is_ucbrs_1(&self) -> bool {
                *self == UCBRSR::UCBRS_1
            }
            #[doc = "Checks if the value of the field is `UCBRS_2`"]
            #[inline(always)]
            pub fn is_ucbrs_2(&self) -> bool {
                *self == UCBRSR::UCBRS_2
            }
            #[doc = "Checks if the value of the field is `UCBRS_3`"]
            #[inline(always)]
            pub fn is_ucbrs_3(&self) -> bool {
                *self == UCBRSR::UCBRS_3
            }
            #[doc = "Checks if the value of the field is `UCBRS_4`"]
            #[inline(always)]
            pub fn is_ucbrs_4(&self) -> bool {
                *self == UCBRSR::UCBRS_4
            }
            #[doc = "Checks if the value of the field is `UCBRS_5`"]
            #[inline(always)]
            pub fn is_ucbrs_5(&self) -> bool {
                *self == UCBRSR::UCBRS_5
            }
            #[doc = "Checks if the value of the field is `UCBRS_6`"]
            #[inline(always)]
            pub fn is_ucbrs_6(&self) -> bool {
                *self == UCBRSR::UCBRS_6
            }
            #[doc = "Checks if the value of the field is `UCBRS_7`"]
            #[inline(always)]
            pub fn is_ucbrs_7(&self) -> bool {
                *self == UCBRSR::UCBRS_7
            }
        }
        #[doc = "Possible values of the field `UCBRF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBRFR {
            #[doc = "USCI First Stage Modulation: 0"]
            UCBRF_0,
            #[doc = "USCI First Stage Modulation: 1"]
            UCBRF_1,
            #[doc = "USCI First Stage Modulation: 2"]
            UCBRF_2,
            #[doc = "USCI First Stage Modulation: 3"]
            UCBRF_3,
            #[doc = "USCI First Stage Modulation: 4"]
            UCBRF_4,
            #[doc = "USCI First Stage Modulation: 5"]
            UCBRF_5,
            #[doc = "USCI First Stage Modulation: 6"]
            UCBRF_6,
            #[doc = "USCI First Stage Modulation: 7"]
            UCBRF_7,
            #[doc = "USCI First Stage Modulation: 8"]
            UCBRF_8,
            #[doc = "USCI First Stage Modulation: 9"]
            UCBRF_9,
            #[doc = "USCI First Stage Modulation: A"]
            UCBRF_10,
            #[doc = "USCI First Stage Modulation: B"]
            UCBRF_11,
            #[doc = "USCI First Stage Modulation: C"]
            UCBRF_12,
            #[doc = "USCI First Stage Modulation: D"]
            UCBRF_13,
            #[doc = "USCI First Stage Modulation: E"]
            UCBRF_14,
            #[doc = "USCI First Stage Modulation: F"]
            UCBRF_15,
        }
        impl UCBRFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCBRFR::UCBRF_0 => 0,
                    UCBRFR::UCBRF_1 => 1,
                    UCBRFR::UCBRF_2 => 2,
                    UCBRFR::UCBRF_3 => 3,
                    UCBRFR::UCBRF_4 => 4,
                    UCBRFR::UCBRF_5 => 5,
                    UCBRFR::UCBRF_6 => 6,
                    UCBRFR::UCBRF_7 => 7,
                    UCBRFR::UCBRF_8 => 8,
                    UCBRFR::UCBRF_9 => 9,
                    UCBRFR::UCBRF_10 => 10,
                    UCBRFR::UCBRF_11 => 11,
                    UCBRFR::UCBRF_12 => 12,
                    UCBRFR::UCBRF_13 => 13,
                    UCBRFR::UCBRF_14 => 14,
                    UCBRFR::UCBRF_15 => 15,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCBRFR {
                match value {
                    0 => UCBRFR::UCBRF_0,
                    1 => UCBRFR::UCBRF_1,
                    2 => UCBRFR::UCBRF_2,
                    3 => UCBRFR::UCBRF_3,
                    4 => UCBRFR::UCBRF_4,
                    5 => UCBRFR::UCBRF_5,
                    6 => UCBRFR::UCBRF_6,
                    7 => UCBRFR::UCBRF_7,
                    8 => UCBRFR::UCBRF_8,
                    9 => UCBRFR::UCBRF_9,
                    10 => UCBRFR::UCBRF_10,
                    11 => UCBRFR::UCBRF_11,
                    12 => UCBRFR::UCBRF_12,
                    13 => UCBRFR::UCBRF_13,
                    14 => UCBRFR::UCBRF_14,
                    15 => UCBRFR::UCBRF_15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCBRF_0`"]
            #[inline(always)]
            pub fn is_ucbrf_0(&self) -> bool {
                *self == UCBRFR::UCBRF_0
            }
            #[doc = "Checks if the value of the field is `UCBRF_1`"]
            #[inline(always)]
            pub fn is_ucbrf_1(&self) -> bool {
                *self == UCBRFR::UCBRF_1
            }
            #[doc = "Checks if the value of the field is `UCBRF_2`"]
            #[inline(always)]
            pub fn is_ucbrf_2(&self) -> bool {
                *self == UCBRFR::UCBRF_2
            }
            #[doc = "Checks if the value of the field is `UCBRF_3`"]
            #[inline(always)]
            pub fn is_ucbrf_3(&self) -> bool {
                *self == UCBRFR::UCBRF_3
            }
            #[doc = "Checks if the value of the field is `UCBRF_4`"]
            #[inline(always)]
            pub fn is_ucbrf_4(&self) -> bool {
                *self == UCBRFR::UCBRF_4
            }
            #[doc = "Checks if the value of the field is `UCBRF_5`"]
            #[inline(always)]
            pub fn is_ucbrf_5(&self) -> bool {
                *self == UCBRFR::UCBRF_5
            }
            #[doc = "Checks if the value of the field is `UCBRF_6`"]
            #[inline(always)]
            pub fn is_ucbrf_6(&self) -> bool {
                *self == UCBRFR::UCBRF_6
            }
            #[doc = "Checks if the value of the field is `UCBRF_7`"]
            #[inline(always)]
            pub fn is_ucbrf_7(&self) -> bool {
                *self == UCBRFR::UCBRF_7
            }
            #[doc = "Checks if the value of the field is `UCBRF_8`"]
            #[inline(always)]
            pub fn is_ucbrf_8(&self) -> bool {
                *self == UCBRFR::UCBRF_8
            }
            #[doc = "Checks if the value of the field is `UCBRF_9`"]
            #[inline(always)]
            pub fn is_ucbrf_9(&self) -> bool {
                *self == UCBRFR::UCBRF_9
            }
            #[doc = "Checks if the value of the field is `UCBRF_10`"]
            #[inline(always)]
            pub fn is_ucbrf_10(&self) -> bool {
                *self == UCBRFR::UCBRF_10
            }
            #[doc = "Checks if the value of the field is `UCBRF_11`"]
            #[inline(always)]
            pub fn is_ucbrf_11(&self) -> bool {
                *self == UCBRFR::UCBRF_11
            }
            #[doc = "Checks if the value of the field is `UCBRF_12`"]
            #[inline(always)]
            pub fn is_ucbrf_12(&self) -> bool {
                *self == UCBRFR::UCBRF_12
            }
            #[doc = "Checks if the value of the field is `UCBRF_13`"]
            #[inline(always)]
            pub fn is_ucbrf_13(&self) -> bool {
                *self == UCBRFR::UCBRF_13
            }
            #[doc = "Checks if the value of the field is `UCBRF_14`"]
            #[inline(always)]
            pub fn is_ucbrf_14(&self) -> bool {
                *self == UCBRFR::UCBRF_14
            }
            #[doc = "Checks if the value of the field is `UCBRF_15`"]
            #[inline(always)]
            pub fn is_ucbrf_15(&self) -> bool {
                *self == UCBRFR::UCBRF_15
            }
        }
        #[doc = "Values that can be written to the field `UCOS16`"]
        pub enum UCOS16W { }
        impl UCOS16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOS16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOS16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOS16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBRS`"]
        pub enum UCBRSW {
            #[doc = "USCI Second Stage Modulation: 0"]
            UCBRS_0,
            #[doc = "USCI Second Stage Modulation: 1"]
            UCBRS_1,
            #[doc = "USCI Second Stage Modulation: 2"]
            UCBRS_2,
            #[doc = "USCI Second Stage Modulation: 3"]
            UCBRS_3,
            #[doc = "USCI Second Stage Modulation: 4"]
            UCBRS_4,
            #[doc = "USCI Second Stage Modulation: 5"]
            UCBRS_5,
            #[doc = "USCI Second Stage Modulation: 6"]
            UCBRS_6,
            #[doc = "USCI Second Stage Modulation: 7"]
            UCBRS_7,
        }
        impl UCBRSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCBRSW::UCBRS_0 => 0,
                    UCBRSW::UCBRS_1 => 1,
                    UCBRSW::UCBRS_2 => 2,
                    UCBRSW::UCBRS_3 => 3,
                    UCBRSW::UCBRS_4 => 4,
                    UCBRSW::UCBRS_5 => 5,
                    UCBRSW::UCBRS_6 => 6,
                    UCBRSW::UCBRS_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBRSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBRSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBRSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI Second Stage Modulation: 0"]
            #[inline(always)]
            pub fn ucbrs_0(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_0)
            }
            #[doc = "USCI Second Stage Modulation: 1"]
            #[inline(always)]
            pub fn ucbrs_1(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_1)
            }
            #[doc = "USCI Second Stage Modulation: 2"]
            #[inline(always)]
            pub fn ucbrs_2(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_2)
            }
            #[doc = "USCI Second Stage Modulation: 3"]
            #[inline(always)]
            pub fn ucbrs_3(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_3)
            }
            #[doc = "USCI Second Stage Modulation: 4"]
            #[inline(always)]
            pub fn ucbrs_4(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_4)
            }
            #[doc = "USCI Second Stage Modulation: 5"]
            #[inline(always)]
            pub fn ucbrs_5(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_5)
            }
            #[doc = "USCI Second Stage Modulation: 6"]
            #[inline(always)]
            pub fn ucbrs_6(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_6)
            }
            #[doc = "USCI Second Stage Modulation: 7"]
            #[inline(always)]
            pub fn ucbrs_7(self) -> &'a mut W {
                self.variant(UCBRSW::UCBRS_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBRF`"]
        pub enum UCBRFW {
            #[doc = "USCI First Stage Modulation: 0"]
            UCBRF_0,
            #[doc = "USCI First Stage Modulation: 1"]
            UCBRF_1,
            #[doc = "USCI First Stage Modulation: 2"]
            UCBRF_2,
            #[doc = "USCI First Stage Modulation: 3"]
            UCBRF_3,
            #[doc = "USCI First Stage Modulation: 4"]
            UCBRF_4,
            #[doc = "USCI First Stage Modulation: 5"]
            UCBRF_5,
            #[doc = "USCI First Stage Modulation: 6"]
            UCBRF_6,
            #[doc = "USCI First Stage Modulation: 7"]
            UCBRF_7,
            #[doc = "USCI First Stage Modulation: 8"]
            UCBRF_8,
            #[doc = "USCI First Stage Modulation: 9"]
            UCBRF_9,
            #[doc = "USCI First Stage Modulation: A"]
            UCBRF_10,
            #[doc = "USCI First Stage Modulation: B"]
            UCBRF_11,
            #[doc = "USCI First Stage Modulation: C"]
            UCBRF_12,
            #[doc = "USCI First Stage Modulation: D"]
            UCBRF_13,
            #[doc = "USCI First Stage Modulation: E"]
            UCBRF_14,
            #[doc = "USCI First Stage Modulation: F"]
            UCBRF_15,
        }
        impl UCBRFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCBRFW::UCBRF_0 => 0,
                    UCBRFW::UCBRF_1 => 1,
                    UCBRFW::UCBRF_2 => 2,
                    UCBRFW::UCBRF_3 => 3,
                    UCBRFW::UCBRF_4 => 4,
                    UCBRFW::UCBRF_5 => 5,
                    UCBRFW::UCBRF_6 => 6,
                    UCBRFW::UCBRF_7 => 7,
                    UCBRFW::UCBRF_8 => 8,
                    UCBRFW::UCBRF_9 => 9,
                    UCBRFW::UCBRF_10 => 10,
                    UCBRFW::UCBRF_11 => 11,
                    UCBRFW::UCBRF_12 => 12,
                    UCBRFW::UCBRF_13 => 13,
                    UCBRFW::UCBRF_14 => 14,
                    UCBRFW::UCBRF_15 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBRFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBRFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBRFW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI First Stage Modulation: 0"]
            #[inline(always)]
            pub fn ucbrf_0(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_0)
            }
            #[doc = "USCI First Stage Modulation: 1"]
            #[inline(always)]
            pub fn ucbrf_1(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_1)
            }
            #[doc = "USCI First Stage Modulation: 2"]
            #[inline(always)]
            pub fn ucbrf_2(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_2)
            }
            #[doc = "USCI First Stage Modulation: 3"]
            #[inline(always)]
            pub fn ucbrf_3(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_3)
            }
            #[doc = "USCI First Stage Modulation: 4"]
            #[inline(always)]
            pub fn ucbrf_4(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_4)
            }
            #[doc = "USCI First Stage Modulation: 5"]
            #[inline(always)]
            pub fn ucbrf_5(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_5)
            }
            #[doc = "USCI First Stage Modulation: 6"]
            #[inline(always)]
            pub fn ucbrf_6(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_6)
            }
            #[doc = "USCI First Stage Modulation: 7"]
            #[inline(always)]
            pub fn ucbrf_7(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_7)
            }
            #[doc = "USCI First Stage Modulation: 8"]
            #[inline(always)]
            pub fn ucbrf_8(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_8)
            }
            #[doc = "USCI First Stage Modulation: 9"]
            #[inline(always)]
            pub fn ucbrf_9(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_9)
            }
            #[doc = "USCI First Stage Modulation: A"]
            #[inline(always)]
            pub fn ucbrf_10(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_10)
            }
            #[doc = "USCI First Stage Modulation: B"]
            #[inline(always)]
            pub fn ucbrf_11(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_11)
            }
            #[doc = "USCI First Stage Modulation: C"]
            #[inline(always)]
            pub fn ucbrf_12(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_12)
            }
            #[doc = "USCI First Stage Modulation: D"]
            #[inline(always)]
            pub fn ucbrf_13(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_13)
            }
            #[doc = "USCI First Stage Modulation: E"]
            #[inline(always)]
            pub fn ucbrf_14(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_14)
            }
            #[doc = "USCI First Stage Modulation: F"]
            #[inline(always)]
            pub fn ucbrf_15(self) -> &'a mut W {
                self.variant(UCBRFW::UCBRF_15)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI 16-times Oversampling enable"]
            #[inline(always)]
            pub fn ucos16(&self) -> UCOS16R {
                UCOS16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 1:3 - USCI Second Stage Modulation Select 2"]
            #[inline(always)]
            pub fn ucbrs(&self) -> UCBRSR {
                UCBRSR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
            #[inline(always)]
            pub fn ucbrf(&self) -> UCBRFR {
                UCBRFR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI 16-times Oversampling enable"]
            #[inline(always)]
            pub fn ucos16(&mut self) -> _UCOS16W {
                _UCOS16W { w: self }
            }
            #[doc = "Bits 1:3 - USCI Second Stage Modulation Select 2"]
            #[inline(always)]
            pub fn ucbrs(&mut self) -> _UCBRSW {
                _UCBRSW { w: self }
            }
            #[doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
            #[inline(always)]
            pub fn ucbrf(&mut self) -> _UCBRFW {
                _UCBRFW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Status Register"]
    pub struct UCA0STAT {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Status Register"]
    pub mod uca0stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCBUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBUSYR {
                match value {
                    i => UCBUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCADDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCADDRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCADDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCADDRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCADDRR {
                match value {
                    i => UCADDRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCRXERR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCRXERRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCRXERRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCRXERRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCRXERRR {
                match value {
                    i => UCRXERRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCBRK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBRKR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBRKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBRKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBRKR {
                match value {
                    i => UCBRKR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCPER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCPER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCPER {
                match value {
                    i => UCPER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOER {
                match value {
                    i => UCOER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCFE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCFER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCFER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCFER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCFER {
                match value {
                    i => UCFER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCLISTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCLISTENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCLISTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCLISTENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCLISTENR {
                match value {
                    i => UCLISTENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCBUSY`"]
        pub enum UCBUSYW { }
        impl UCBUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCADDR`"]
        pub enum UCADDRW { }
        impl UCADDRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCADDRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCADDRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCRXERR`"]
        pub enum UCRXERRW { }
        impl UCRXERRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCRXERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCRXERRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCRXERRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBRK`"]
        pub enum UCBRKW { }
        impl UCBRKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBRKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBRKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCPE`"]
        pub enum UCPEW { }
        impl UCPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOE`"]
        pub enum UCOEW { }
        impl UCOEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCFE`"]
        pub enum UCFEW { }
        impl UCFEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCFEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCFEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCFEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCLISTEN`"]
        pub enum UCLISTENW { }
        impl UCLISTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCLISTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCLISTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCLISTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&self) -> UCBUSYR {
                UCBUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - USCI Address received Flag"]
            #[inline(always)]
            pub fn ucaddr(&self) -> UCADDRR {
                UCADDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - USCI RX Error Flag"]
            #[inline(always)]
            pub fn ucrxerr(&self) -> UCRXERRR {
                UCRXERRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - USCI Break received"]
            #[inline(always)]
            pub fn ucbrk(&self) -> UCBRKR {
                UCBRKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - USCI Parity Error Flag"]
            #[inline(always)]
            pub fn ucpe(&self) -> UCPER {
                UCPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&self) -> UCOER {
                UCOER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&self) -> UCFER {
                UCFER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&self) -> UCLISTENR {
                UCLISTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&mut self) -> _UCBUSYW {
                _UCBUSYW { w: self }
            }
            #[doc = "Bit 1 - USCI Address received Flag"]
            #[inline(always)]
            pub fn ucaddr(&mut self) -> _UCADDRW {
                _UCADDRW { w: self }
            }
            #[doc = "Bit 2 - USCI RX Error Flag"]
            #[inline(always)]
            pub fn ucrxerr(&mut self) -> _UCRXERRW {
                _UCRXERRW { w: self }
            }
            #[doc = "Bit 3 - USCI Break received"]
            #[inline(always)]
            pub fn ucbrk(&mut self) -> _UCBRKW {
                _UCBRKW { w: self }
            }
            #[doc = "Bit 4 - USCI Parity Error Flag"]
            #[inline(always)]
            pub fn ucpe(&mut self) -> _UCPEW {
                _UCPEW { w: self }
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&mut self) -> _UCOEW {
                _UCOEW { w: self }
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&mut self) -> _UCFEW {
                _UCFEW { w: self }
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&mut self) -> _UCLISTENW {
                _UCLISTENW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Receive Buffer"]
    pub struct UCA0RXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Receive Buffer"]
    pub mod uca0rxbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0RXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Transmit Buffer"]
    pub struct UCA0TXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Transmit Buffer"]
    pub mod uca0txbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0TXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "USCI_A0 UART Mode"]
pub struct USCI_A0_UART_MODE {
    register_block: usci_a0_uart_mode::RegisterBlock,
}
impl Deref for USCI_A0_UART_MODE {
    type Target = usci_a0_uart_mode::RegisterBlock;
    fn deref(&self) -> &usci_a0_uart_mode::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Watchdog Timer"]
pub const WATCHDOG_TIMER: Peripheral<WATCHDOG_TIMER> =
    unsafe { Peripheral::new(288) };
#[doc = "Watchdog Timer"]
pub mod watchdog_timer {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Watchdog Timer Control"]
        pub wdtctl: WDTCTL,
    }
    #[doc = "Watchdog Timer Control"]
    pub struct WDTCTL {
        register: VolatileCell<u16>,
    }
    #[doc = "Watchdog Timer Control"]
    pub mod wdtctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::WDTCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDTIS0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTIS0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTIS0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTIS0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTIS0R {
                match value {
                    i => WDTIS0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTIS1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTIS1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTIS1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTIS1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTIS1R {
                match value {
                    i => WDTIS1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTSSELR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTSSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTSSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTSSELR {
                match value {
                    i => WDTSSELR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTCNTCL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTCNTCLR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTCNTCLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTCNTCLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTCNTCLR {
                match value {
                    i => WDTCNTCLR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTTMSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTTMSELR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTTMSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTTMSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTTMSELR {
                match value {
                    i => WDTTMSELR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTNMI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTNMIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTNMIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTNMIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTNMIR {
                match value {
                    i => WDTNMIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTNMIES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTNMIESR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTNMIESR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTNMIESR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTNMIESR {
                match value {
                    i => WDTNMIESR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `WDTHOLD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTHOLDR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTHOLDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTHOLDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTHOLDR {
                match value {
                    i => WDTHOLDR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `WDTIS0`"]
        pub enum WDTIS0W { }
        impl WDTIS0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTIS0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTIS0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTIS0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTIS1`"]
        pub enum WDTIS1W { }
        impl WDTIS1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTIS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTIS1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTIS1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTSSEL`"]
        pub enum WDTSSELW { }
        impl WDTSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTSSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTCNTCL`"]
        pub enum WDTCNTCLW { }
        impl WDTCNTCLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTCNTCLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTCNTCLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTCNTCLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTTMSEL`"]
        pub enum WDTTMSELW { }
        impl WDTTMSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTTMSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTTMSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTTMSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTNMI`"]
        pub enum WDTNMIW { }
        impl WDTNMIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTNMIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTNMIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTNMIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTNMIES`"]
        pub enum WDTNMIESW { }
        impl WDTNMIESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTNMIESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTNMIESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTNMIESW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTHOLD`"]
        pub enum WDTHOLDW { }
        impl WDTHOLDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTHOLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTHOLDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTHOLDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - WDTIS0"]
            #[inline(always)]
            pub fn wdtis0(&self) -> WDTIS0R {
                WDTIS0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - WDTIS1"]
            #[inline(always)]
            pub fn wdtis1(&self) -> WDTIS1R {
                WDTIS1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - WDTSSEL"]
            #[inline(always)]
            pub fn wdtssel(&self) -> WDTSSELR {
                WDTSSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - WDTCNTCL"]
            #[inline(always)]
            pub fn wdtcntcl(&self) -> WDTCNTCLR {
                WDTCNTCLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - WDTTMSEL"]
            #[inline(always)]
            pub fn wdttmsel(&self) -> WDTTMSELR {
                WDTTMSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - WDTNMI"]
            #[inline(always)]
            pub fn wdtnmi(&self) -> WDTNMIR {
                WDTNMIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - WDTNMIES"]
            #[inline(always)]
            pub fn wdtnmies(&self) -> WDTNMIESR {
                WDTNMIESR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - WDTHOLD"]
            #[inline(always)]
            pub fn wdthold(&self) -> WDTHOLDR {
                WDTHOLDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - WDTIS0"]
            #[inline(always)]
            pub fn wdtis0(&mut self) -> _WDTIS0W {
                _WDTIS0W { w: self }
            }
            #[doc = "Bit 1 - WDTIS1"]
            #[inline(always)]
            pub fn wdtis1(&mut self) -> _WDTIS1W {
                _WDTIS1W { w: self }
            }
            #[doc = "Bit 2 - WDTSSEL"]
            #[inline(always)]
            pub fn wdtssel(&mut self) -> _WDTSSELW {
                _WDTSSELW { w: self }
            }
            #[doc = "Bit 3 - WDTCNTCL"]
            #[inline(always)]
            pub fn wdtcntcl(&mut self) -> _WDTCNTCLW {
                _WDTCNTCLW { w: self }
            }
            #[doc = "Bit 4 - WDTTMSEL"]
            #[inline(always)]
            pub fn wdttmsel(&mut self) -> _WDTTMSELW {
                _WDTTMSELW { w: self }
            }
            #[doc = "Bit 5 - WDTNMI"]
            #[inline(always)]
            pub fn wdtnmi(&mut self) -> _WDTNMIW {
                _WDTNMIW { w: self }
            }
            #[doc = "Bit 6 - WDTNMIES"]
            #[inline(always)]
            pub fn wdtnmies(&mut self) -> _WDTNMIESW {
                _WDTNMIESW { w: self }
            }
            #[doc = "Bit 7 - WDTHOLD"]
            #[inline(always)]
            pub fn wdthold(&mut self) -> _WDTHOLDW {
                _WDTHOLDW { w: self }
            }
        }
    }
}
#[doc = "Watchdog Timer"]
pub struct WATCHDOG_TIMER {
    register_block: watchdog_timer::RegisterBlock,
}
impl Deref for WATCHDOG_TIMER {
    type Target = watchdog_timer::RegisterBlock;
    fn deref(&self) -> &watchdog_timer::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Comparator A"]
pub const COMPARATOR_A: Peripheral<COMPARATOR_A> =
    unsafe { Peripheral::new(88) };
#[doc = "Comparator A"]
pub mod comparator_a {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1usize],
        #[doc = "0x01 - Comparator A Control 1"]
        pub cactl1: CACTL1,
        #[doc = "0x02 - Comparator A Control 2"]
        pub cactl2: CACTL2,
        #[doc = "0x03 - Comparator A Port Disable"]
        pub capd: CAPD,
    }
    #[doc = "Comparator A Control 1"]
    pub struct CACTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "Comparator A Control 1"]
    pub mod cactl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CACTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CAIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAIFGR {
                match value {
                    i => CAIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAIER {
                match value {
                    i => CAIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAIES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAIESR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAIESR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAIESR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAIESR {
                match value {
                    i => CAIESR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAONR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAONR {
                match value {
                    i => CAONR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAREF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAREFR {
            #[doc = "Comp. A Int. Ref. Select 0 : Off"]
            CAREF_0,
            #[doc = "Comp. A Int. Ref. Select 1 : 0.25*Vcc"]
            CAREF_1,
            #[doc = "Comp. A Int. Ref. Select 2 : 0.5*Vcc"]
            CAREF_2,
            #[doc = "Comp. A Int. Ref. Select 3 : Vt"]
            CAREF_3,
        }
        impl CAREFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CAREFR::CAREF_0 => 0,
                    CAREFR::CAREF_1 => 1,
                    CAREFR::CAREF_2 => 2,
                    CAREFR::CAREF_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CAREFR {
                match value {
                    0 => CAREFR::CAREF_0,
                    1 => CAREFR::CAREF_1,
                    2 => CAREFR::CAREF_2,
                    3 => CAREFR::CAREF_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CAREF_0`"]
            #[inline(always)]
            pub fn is_caref_0(&self) -> bool {
                *self == CAREFR::CAREF_0
            }
            #[doc = "Checks if the value of the field is `CAREF_1`"]
            #[inline(always)]
            pub fn is_caref_1(&self) -> bool {
                *self == CAREFR::CAREF_1
            }
            #[doc = "Checks if the value of the field is `CAREF_2`"]
            #[inline(always)]
            pub fn is_caref_2(&self) -> bool {
                *self == CAREFR::CAREF_2
            }
            #[doc = "Checks if the value of the field is `CAREF_3`"]
            #[inline(always)]
            pub fn is_caref_3(&self) -> bool {
                *self == CAREFR::CAREF_3
            }
        }
        #[doc = "Possible values of the field `CARSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CARSELR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CARSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CARSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CARSELR {
                match value {
                    i => CARSELR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAEX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAEXR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAEXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAEXR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAEXR {
                match value {
                    i => CAEXR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `CAIFG`"]
        pub enum CAIFGW { }
        impl CAIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAIE`"]
        pub enum CAIEW { }
        impl CAIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAIES`"]
        pub enum CAIESW { }
        impl CAIESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAIESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAIESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAIESW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAON`"]
        pub enum CAONW { }
        impl CAONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAREF`"]
        pub enum CAREFW {
            #[doc = "Comp. A Int. Ref. Select 0 : Off"]
            CAREF_0,
            #[doc = "Comp. A Int. Ref. Select 1 : 0.25*Vcc"]
            CAREF_1,
            #[doc = "Comp. A Int. Ref. Select 2 : 0.5*Vcc"]
            CAREF_2,
            #[doc = "Comp. A Int. Ref. Select 3 : Vt"]
            CAREF_3,
        }
        impl CAREFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CAREFW::CAREF_0 => 0,
                    CAREFW::CAREF_1 => 1,
                    CAREFW::CAREF_2 => 2,
                    CAREFW::CAREF_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAREFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAREFW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Comp. A Int. Ref. Select 0 : Off"]
            #[inline(always)]
            pub fn caref_0(self) -> &'a mut W {
                self.variant(CAREFW::CAREF_0)
            }
            #[doc = "Comp. A Int. Ref. Select 1 : 0.25*Vcc"]
            #[inline(always)]
            pub fn caref_1(self) -> &'a mut W {
                self.variant(CAREFW::CAREF_1)
            }
            #[doc = "Comp. A Int. Ref. Select 2 : 0.5*Vcc"]
            #[inline(always)]
            pub fn caref_2(self) -> &'a mut W {
                self.variant(CAREFW::CAREF_2)
            }
            #[doc = "Comp. A Int. Ref. Select 3 : Vt"]
            #[inline(always)]
            pub fn caref_3(self) -> &'a mut W {
                self.variant(CAREFW::CAREF_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CARSEL`"]
        pub enum CARSELW { }
        impl CARSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CARSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CARSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CARSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAEX`"]
        pub enum CAEXW { }
        impl CAEXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAEXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAEXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAEXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comp. A Interrupt Flag"]
            #[inline(always)]
            pub fn caifg(&self) -> CAIFGR {
                CAIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Comp. A Interrupt Enable"]
            #[inline(always)]
            pub fn caie(&self) -> CAIER {
                CAIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Comp. A Int. Edge Select: 0:rising / 1:falling"]
            #[inline(always)]
            pub fn caies(&self) -> CAIESR {
                CAIESR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Comp. A enable"]
            #[inline(always)]
            pub fn caon(&self) -> CAONR {
                CAONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 4:5 - Comp. A Internal Reference Select 0"]
            #[inline(always)]
            pub fn caref(&self) -> CAREFR {
                CAREFR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 6 - Comp. A Internal Reference Enable"]
            #[inline(always)]
            pub fn carsel(&self) -> CARSELR {
                CARSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Comp. A Exchange Inputs"]
            #[inline(always)]
            pub fn caex(&self) -> CAEXR {
                CAEXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comp. A Interrupt Flag"]
            #[inline(always)]
            pub fn caifg(&mut self) -> _CAIFGW {
                _CAIFGW { w: self }
            }
            #[doc = "Bit 1 - Comp. A Interrupt Enable"]
            #[inline(always)]
            pub fn caie(&mut self) -> _CAIEW {
                _CAIEW { w: self }
            }
            #[doc = "Bit 2 - Comp. A Int. Edge Select: 0:rising / 1:falling"]
            #[inline(always)]
            pub fn caies(&mut self) -> _CAIESW {
                _CAIESW { w: self }
            }
            #[doc = "Bit 3 - Comp. A enable"]
            #[inline(always)]
            pub fn caon(&mut self) -> _CAONW {
                _CAONW { w: self }
            }
            #[doc = "Bits 4:5 - Comp. A Internal Reference Select 0"]
            #[inline(always)]
            pub fn caref(&mut self) -> _CAREFW {
                _CAREFW { w: self }
            }
            #[doc = "Bit 6 - Comp. A Internal Reference Enable"]
            #[inline(always)]
            pub fn carsel(&mut self) -> _CARSELW {
                _CARSELW { w: self }
            }
            #[doc = "Bit 7 - Comp. A Exchange Inputs"]
            #[inline(always)]
            pub fn caex(&mut self) -> _CAEXW {
                _CAEXW { w: self }
            }
        }
    }
    #[doc = "Comparator A Control 2"]
    pub struct CACTL2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Comparator A Control 2"]
    pub mod cactl2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CACTL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CAOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAOUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAOUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAOUTR {
                match value {
                    i => CAOUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAFR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAFR {
                match value {
                    i => CAFR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2CA0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2CA0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2CA0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2CA0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2CA0R {
                match value {
                    i => P2CA0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2CA1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2CA1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2CA1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2CA1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2CA1R {
                match value {
                    i => P2CA1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2CA2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2CA2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2CA2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2CA2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2CA2R {
                match value {
                    i => P2CA2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2CA3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2CA3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2CA3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2CA3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2CA3R {
                match value {
                    i => P2CA3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2CA4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2CA4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2CA4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2CA4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2CA4R {
                match value {
                    i => P2CA4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CASHORT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CASHORTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CASHORTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CASHORTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CASHORTR {
                match value {
                    i => CASHORTR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `CAOUT`"]
        pub enum CAOUTW { }
        impl CAOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAF`"]
        pub enum CAFW { }
        impl CAFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2CA0`"]
        pub enum P2CA0W { }
        impl P2CA0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2CA0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2CA0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2CA0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2CA1`"]
        pub enum P2CA1W { }
        impl P2CA1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2CA1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2CA1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2CA1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2CA2`"]
        pub enum P2CA2W { }
        impl P2CA2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2CA2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2CA2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2CA2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2CA3`"]
        pub enum P2CA3W { }
        impl P2CA3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2CA3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2CA3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2CA3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2CA4`"]
        pub enum P2CA4W { }
        impl P2CA4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2CA4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2CA4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2CA4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CASHORT`"]
        pub enum CASHORTW { }
        impl CASHORTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CASHORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CASHORTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CASHORTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comp. A Output"]
            #[inline(always)]
            pub fn caout(&self) -> CAOUTR {
                CAOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Comp. A Enable Output Filter"]
            #[inline(always)]
            pub fn caf(&self) -> CAFR {
                CAFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Comp. A +Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca0(&self) -> P2CA0R {
                P2CA0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca1(&self) -> P2CA1R {
                P2CA1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca2(&self) -> P2CA2R {
                P2CA2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca3(&self) -> P2CA3R {
                P2CA3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - Comp. A +Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca4(&self) -> P2CA4R {
                P2CA4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Comp. A Short + and - Terminals"]
            #[inline(always)]
            pub fn cashort(&self) -> CASHORTR {
                CASHORTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comp. A Output"]
            #[inline(always)]
            pub fn caout(&mut self) -> _CAOUTW {
                _CAOUTW { w: self }
            }
            #[doc = "Bit 1 - Comp. A Enable Output Filter"]
            #[inline(always)]
            pub fn caf(&mut self) -> _CAFW {
                _CAFW { w: self }
            }
            #[doc = "Bit 2 - Comp. A +Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca0(&mut self) -> _P2CA0W {
                _P2CA0W { w: self }
            }
            #[doc = "Bit 3 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca1(&mut self) -> _P2CA1W {
                _P2CA1W { w: self }
            }
            #[doc = "Bit 4 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca2(&mut self) -> _P2CA2W {
                _P2CA2W { w: self }
            }
            #[doc = "Bit 5 - Comp. A -Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca3(&mut self) -> _P2CA3W {
                _P2CA3W { w: self }
            }
            #[doc = "Bit 6 - Comp. A +Terminal Multiplexer"]
            #[inline(always)]
            pub fn p2ca4(&mut self) -> _P2CA4W {
                _P2CA4W { w: self }
            }
            #[doc = "Bit 7 - Comp. A Short + and - Terminals"]
            #[inline(always)]
            pub fn cashort(&mut self) -> _CASHORTW {
                _CASHORTW { w: self }
            }
        }
    }
    #[doc = "Comparator A Port Disable"]
    pub struct CAPD {
        register: VolatileCell<u8>,
    }
    #[doc = "Comparator A Port Disable"]
    pub mod capd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CAPD {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CAPD0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD0R {
                match value {
                    i => CAPD0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD1R {
                match value {
                    i => CAPD1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD2R {
                match value {
                    i => CAPD2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD3R {
                match value {
                    i => CAPD3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD4R {
                match value {
                    i => CAPD4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD5R {
                match value {
                    i => CAPD5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD6R {
                match value {
                    i => CAPD6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CAPD7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPD7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPD7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPD7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPD7R {
                match value {
                    i => CAPD7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `CAPD0`"]
        pub enum CAPD0W { }
        impl CAPD0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD1`"]
        pub enum CAPD1W { }
        impl CAPD1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD2`"]
        pub enum CAPD2W { }
        impl CAPD2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD3`"]
        pub enum CAPD3W { }
        impl CAPD3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD4`"]
        pub enum CAPD4W { }
        impl CAPD4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD5`"]
        pub enum CAPD5W { }
        impl CAPD5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD6`"]
        pub enum CAPD6W { }
        impl CAPD6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAPD7`"]
        pub enum CAPD7W { }
        impl CAPD7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPD7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPD7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comp. A Disable Input Buffer of Port Register .0"]
            #[inline(always)]
            pub fn capd0(&self) -> CAPD0R {
                CAPD0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Comp. A Disable Input Buffer of Port Register .1"]
            #[inline(always)]
            pub fn capd1(&self) -> CAPD1R {
                CAPD1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Comp. A Disable Input Buffer of Port Register .2"]
            #[inline(always)]
            pub fn capd2(&self) -> CAPD2R {
                CAPD2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Comp. A Disable Input Buffer of Port Register .3"]
            #[inline(always)]
            pub fn capd3(&self) -> CAPD3R {
                CAPD3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Comp. A Disable Input Buffer of Port Register .4"]
            #[inline(always)]
            pub fn capd4(&self) -> CAPD4R {
                CAPD4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Comp. A Disable Input Buffer of Port Register .5"]
            #[inline(always)]
            pub fn capd5(&self) -> CAPD5R {
                CAPD5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - Comp. A Disable Input Buffer of Port Register .6"]
            #[inline(always)]
            pub fn capd6(&self) -> CAPD6R {
                CAPD6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Comp. A Disable Input Buffer of Port Register .7"]
            #[inline(always)]
            pub fn capd7(&self) -> CAPD7R {
                CAPD7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comp. A Disable Input Buffer of Port Register .0"]
            #[inline(always)]
            pub fn capd0(&mut self) -> _CAPD0W {
                _CAPD0W { w: self }
            }
            #[doc = "Bit 1 - Comp. A Disable Input Buffer of Port Register .1"]
            #[inline(always)]
            pub fn capd1(&mut self) -> _CAPD1W {
                _CAPD1W { w: self }
            }
            #[doc = "Bit 2 - Comp. A Disable Input Buffer of Port Register .2"]
            #[inline(always)]
            pub fn capd2(&mut self) -> _CAPD2W {
                _CAPD2W { w: self }
            }
            #[doc = "Bit 3 - Comp. A Disable Input Buffer of Port Register .3"]
            #[inline(always)]
            pub fn capd3(&mut self) -> _CAPD3W {
                _CAPD3W { w: self }
            }
            #[doc = "Bit 4 - Comp. A Disable Input Buffer of Port Register .4"]
            #[inline(always)]
            pub fn capd4(&mut self) -> _CAPD4W {
                _CAPD4W { w: self }
            }
            #[doc = "Bit 5 - Comp. A Disable Input Buffer of Port Register .5"]
            #[inline(always)]
            pub fn capd5(&mut self) -> _CAPD5W {
                _CAPD5W { w: self }
            }
            #[doc = "Bit 6 - Comp. A Disable Input Buffer of Port Register .6"]
            #[inline(always)]
            pub fn capd6(&mut self) -> _CAPD6W {
                _CAPD6W { w: self }
            }
            #[doc = "Bit 7 - Comp. A Disable Input Buffer of Port Register .7"]
            #[inline(always)]
            pub fn capd7(&mut self) -> _CAPD7W {
                _CAPD7W { w: self }
            }
        }
    }
}
#[doc = "Comparator A"]
pub struct COMPARATOR_A {
    register_block: comparator_a::RegisterBlock,
}
impl Deref for COMPARATOR_A {
    type Target = comparator_a::RegisterBlock;
    fn deref(&self) -> &comparator_a::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Timer1_A3"]
pub const TIMER1_A3: Peripheral<TIMER1_A3> = unsafe { Peripheral::new(286) };
#[doc = "Timer1_A3"]
pub mod timer1_a3 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Timer1_A3 Interrupt Vector Word"]
        pub ta1iv: TA1IV,
        _reserved0: [u8; 96usize],
        #[doc = "0x62 - Timer1_A3 Control"]
        pub ta1ctl: TA1CTL,
        #[doc = "0x64 - Timer1_A3 Capture/Compare Control 0"]
        pub ta1cctl0: TA1CCTL0,
        #[doc = "0x66 - Timer1_A3 Capture/Compare Control 1"]
        pub ta1cctl1: TA1CCTL1,
        #[doc = "0x68 - Timer1_A3 Capture/Compare Control 2"]
        pub ta1cctl2: TA1CCTL2,
        _reserved1: [u8; 8usize],
        #[doc = "0x72 - Timer1_A3 Counter Register"]
        pub ta1r: TA1R,
        #[doc = "0x74 - Timer1_A3 Capture/Compare 0"]
        pub ta1ccr0: TA1CCR0,
        #[doc = "0x76 - Timer1_A3 Capture/Compare 1"]
        pub ta1ccr1: TA1CCR1,
        #[doc = "0x78 - Timer1_A3 Capture/Compare 2"]
        pub ta1ccr2: TA1CCR2,
    }
    #[doc = "Timer1_A3 Interrupt Vector Word"]
    pub struct TA1IV {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Interrupt Vector Word"]
    pub mod ta1iv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1IV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer1_A3 Control"]
    pub struct TA1CTL {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Control"]
    pub mod ta1ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TAIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TAIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TAIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TAIFGR {
                match value {
                    i => TAIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `TAIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TAIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TAIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TAIER {
                match value {
                    i => TAIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `TACLR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TACLRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TACLRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TACLRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TACLRR {
                match value {
                    i => TACLRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MCR {
            #[doc = "Timer A mode control: 0 - Stop"]
            MC_0,
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            MC_1,
            #[doc = "Timer A mode control: 2 - Continous up"]
            MC_2,
            #[doc = "Timer A mode control: 3 - Up/Down"]
            MC_3,
        }
        impl MCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MCR::MC_0 => 0,
                    MCR::MC_1 => 1,
                    MCR::MC_2 => 2,
                    MCR::MC_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MCR {
                match value {
                    0 => MCR::MC_0,
                    1 => MCR::MC_1,
                    2 => MCR::MC_2,
                    3 => MCR::MC_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MC_0`"]
            #[inline(always)]
            pub fn is_mc_0(&self) -> bool {
                *self == MCR::MC_0
            }
            #[doc = "Checks if the value of the field is `MC_1`"]
            #[inline(always)]
            pub fn is_mc_1(&self) -> bool {
                *self == MCR::MC_1
            }
            #[doc = "Checks if the value of the field is `MC_2`"]
            #[inline(always)]
            pub fn is_mc_2(&self) -> bool {
                *self == MCR::MC_2
            }
            #[doc = "Checks if the value of the field is `MC_3`"]
            #[inline(always)]
            pub fn is_mc_3(&self) -> bool {
                *self == MCR::MC_3
            }
        }
        #[doc = "Possible values of the field `ID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR {
            #[doc = "Timer A input divider: 0 - /1"]
            ID_0,
            #[doc = "Timer A input divider: 1 - /2"]
            ID_1,
            #[doc = "Timer A input divider: 2 - /4"]
            ID_2,
            #[doc = "Timer A input divider: 3 - /8"]
            ID_3,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDR::ID_0 => 0,
                    IDR::ID_1 => 1,
                    IDR::ID_2 => 2,
                    IDR::ID_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IDR {
                match value {
                    0 => IDR::ID_0,
                    1 => IDR::ID_1,
                    2 => IDR::ID_2,
                    3 => IDR::ID_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ID_0`"]
            #[inline(always)]
            pub fn is_id_0(&self) -> bool {
                *self == IDR::ID_0
            }
            #[doc = "Checks if the value of the field is `ID_1`"]
            #[inline(always)]
            pub fn is_id_1(&self) -> bool {
                *self == IDR::ID_1
            }
            #[doc = "Checks if the value of the field is `ID_2`"]
            #[inline(always)]
            pub fn is_id_2(&self) -> bool {
                *self == IDR::ID_2
            }
            #[doc = "Checks if the value of the field is `ID_3`"]
            #[inline(always)]
            pub fn is_id_3(&self) -> bool {
                *self == IDR::ID_3
            }
        }
        #[doc = "Possible values of the field `TASSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TASSELR {
            #[doc = "Timer A clock source select: 0 - TACLK"]
            TASSEL_0,
            #[doc = "Timer A clock source select: 1 - ACLK"]
            TASSEL_1,
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            TASSEL_2,
            #[doc = "Timer A clock source select: 3 - INCLK"]
            TASSEL_3,
        }
        impl TASSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    TASSELR::TASSEL_0 => 0,
                    TASSELR::TASSEL_1 => 1,
                    TASSELR::TASSEL_2 => 2,
                    TASSELR::TASSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> TASSELR {
                match value {
                    0 => TASSELR::TASSEL_0,
                    1 => TASSELR::TASSEL_1,
                    2 => TASSELR::TASSEL_2,
                    3 => TASSELR::TASSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TASSEL_0`"]
            #[inline(always)]
            pub fn is_tassel_0(&self) -> bool {
                *self == TASSELR::TASSEL_0
            }
            #[doc = "Checks if the value of the field is `TASSEL_1`"]
            #[inline(always)]
            pub fn is_tassel_1(&self) -> bool {
                *self == TASSELR::TASSEL_1
            }
            #[doc = "Checks if the value of the field is `TASSEL_2`"]
            #[inline(always)]
            pub fn is_tassel_2(&self) -> bool {
                *self == TASSELR::TASSEL_2
            }
            #[doc = "Checks if the value of the field is `TASSEL_3`"]
            #[inline(always)]
            pub fn is_tassel_3(&self) -> bool {
                *self == TASSELR::TASSEL_3
            }
        }
        #[doc = "Values that can be written to the field `TAIFG`"]
        pub enum TAIFGW { }
        impl TAIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TAIE`"]
        pub enum TAIEW { }
        impl TAIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TACLR`"]
        pub enum TACLRW { }
        impl TACLRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TACLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TACLRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TACLRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MC`"]
        pub enum MCW {
            #[doc = "Timer A mode control: 0 - Stop"]
            MC_0,
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            MC_1,
            #[doc = "Timer A mode control: 2 - Continous up"]
            MC_2,
            #[doc = "Timer A mode control: 3 - Up/Down"]
            MC_3,
        }
        impl MCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MCW::MC_0 => 0,
                    MCW::MC_1 => 1,
                    MCW::MC_2 => 2,
                    MCW::MC_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A mode control: 0 - Stop"]
            #[inline(always)]
            pub fn mc_0(self) -> &'a mut W {
                self.variant(MCW::MC_0)
            }
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            #[inline(always)]
            pub fn mc_1(self) -> &'a mut W {
                self.variant(MCW::MC_1)
            }
            #[doc = "Timer A mode control: 2 - Continous up"]
            #[inline(always)]
            pub fn mc_2(self) -> &'a mut W {
                self.variant(MCW::MC_2)
            }
            #[doc = "Timer A mode control: 3 - Up/Down"]
            #[inline(always)]
            pub fn mc_3(self) -> &'a mut W {
                self.variant(MCW::MC_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ID`"]
        pub enum IDW {
            #[doc = "Timer A input divider: 0 - /1"]
            ID_0,
            #[doc = "Timer A input divider: 1 - /2"]
            ID_1,
            #[doc = "Timer A input divider: 2 - /4"]
            ID_2,
            #[doc = "Timer A input divider: 3 - /8"]
            ID_3,
        }
        impl IDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDW::ID_0 => 0,
                    IDW::ID_1 => 1,
                    IDW::ID_2 => 2,
                    IDW::ID_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A input divider: 0 - /1"]
            #[inline(always)]
            pub fn id_0(self) -> &'a mut W {
                self.variant(IDW::ID_0)
            }
            #[doc = "Timer A input divider: 1 - /2"]
            #[inline(always)]
            pub fn id_1(self) -> &'a mut W {
                self.variant(IDW::ID_1)
            }
            #[doc = "Timer A input divider: 2 - /4"]
            #[inline(always)]
            pub fn id_2(self) -> &'a mut W {
                self.variant(IDW::ID_2)
            }
            #[doc = "Timer A input divider: 3 - /8"]
            #[inline(always)]
            pub fn id_3(self) -> &'a mut W {
                self.variant(IDW::ID_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TASSEL`"]
        pub enum TASSELW {
            #[doc = "Timer A clock source select: 0 - TACLK"]
            TASSEL_0,
            #[doc = "Timer A clock source select: 1 - ACLK"]
            TASSEL_1,
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            TASSEL_2,
            #[doc = "Timer A clock source select: 3 - INCLK"]
            TASSEL_3,
        }
        impl TASSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TASSELW::TASSEL_0 => 0,
                    TASSELW::TASSEL_1 => 1,
                    TASSELW::TASSEL_2 => 2,
                    TASSELW::TASSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TASSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TASSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TASSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A clock source select: 0 - TACLK"]
            #[inline(always)]
            pub fn tassel_0(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_0)
            }
            #[doc = "Timer A clock source select: 1 - ACLK"]
            #[inline(always)]
            pub fn tassel_1(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_1)
            }
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            #[inline(always)]
            pub fn tassel_2(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_2)
            }
            #[doc = "Timer A clock source select: 3 - INCLK"]
            #[inline(always)]
            pub fn tassel_3(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&self) -> TAIFGR {
                TAIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&self) -> TAIER {
                TAIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&self) -> TACLRR {
                TACLRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&self) -> MCR {
                MCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                IDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&self) -> TASSELR {
                TASSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&mut self) -> _TAIFGW {
                _TAIFGW { w: self }
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&mut self) -> _TAIEW {
                _TAIEW { w: self }
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&mut self) -> _TACLRW {
                _TACLRW { w: self }
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&mut self) -> _MCW {
                _MCW { w: self }
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&mut self) -> _TASSELW {
                _TASSELW { w: self }
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare Control 0"]
    pub struct TA1CCTL0 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare Control 0"]
    pub mod ta1cctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare Control 1"]
    pub struct TA1CCTL1 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare Control 1"]
    pub mod ta1cctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare Control 2"]
    pub struct TA1CCTL2 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare Control 2"]
    pub mod ta1cctl2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCTL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer1_A3 Counter Register"]
    pub struct TA1R {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Counter Register"]
    pub mod ta1r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1R {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare 0"]
    pub struct TA1CCR0 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare 0"]
    pub mod ta1ccr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare 1"]
    pub struct TA1CCR1 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare 1"]
    pub mod ta1ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer1_A3 Capture/Compare 2"]
    pub struct TA1CCR2 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer1_A3 Capture/Compare 2"]
    pub mod ta1ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA1CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Timer1_A3"]
pub struct TIMER1_A3 {
    register_block: timer1_a3::RegisterBlock,
}
impl Deref for TIMER1_A3 {
    type Target = timer1_a3::RegisterBlock;
    fn deref(&self) -> &timer1_a3::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Timer0_A3"]
pub const TIMER0_A3: Peripheral<TIMER0_A3> = unsafe { Peripheral::new(302) };
#[doc = "Timer0_A3"]
pub mod timer0_a3 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Timer0_A3 Interrupt Vector Word"]
        pub ta0iv: TA0IV,
        _reserved0: [u8; 48usize],
        #[doc = "0x32 - Timer0_A3 Control"]
        pub ta0ctl: TA0CTL,
        #[doc = "0x34 - Timer0_A3 Capture/Compare Control 0"]
        pub ta0cctl0: TA0CCTL0,
        #[doc = "0x36 - Timer0_A3 Capture/Compare Control 1"]
        pub ta0cctl1: TA0CCTL1,
        #[doc = "0x38 - Timer0_A3 Capture/Compare Control 2"]
        pub ta0cctl2: TA0CCTL2,
        _reserved1: [u8; 8usize],
        #[doc = "0x42 - Timer0_A3 Counter Register"]
        pub ta0r: TA0R,
        #[doc = "0x44 - Timer0_A3 Capture/Compare 0"]
        pub ta0ccr0: TA0CCR0,
        #[doc = "0x46 - Timer0_A3 Capture/Compare 1"]
        pub ta0ccr1: TA0CCR1,
        #[doc = "0x48 - Timer0_A3 Capture/Compare 2"]
        pub ta0ccr2: TA0CCR2,
    }
    #[doc = "Timer0_A3 Interrupt Vector Word"]
    pub struct TA0IV {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Interrupt Vector Word"]
    pub mod ta0iv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0IV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer0_A3 Control"]
    pub struct TA0CTL {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Control"]
    pub mod ta0ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TAIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TAIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TAIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TAIFGR {
                match value {
                    i => TAIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `TAIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TAIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TAIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TAIER {
                match value {
                    i => TAIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `TACLR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TACLRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TACLRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TACLRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TACLRR {
                match value {
                    i => TACLRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MCR {
            #[doc = "Timer A mode control: 0 - Stop"]
            MC_0,
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            MC_1,
            #[doc = "Timer A mode control: 2 - Continous up"]
            MC_2,
            #[doc = "Timer A mode control: 3 - Up/Down"]
            MC_3,
        }
        impl MCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MCR::MC_0 => 0,
                    MCR::MC_1 => 1,
                    MCR::MC_2 => 2,
                    MCR::MC_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MCR {
                match value {
                    0 => MCR::MC_0,
                    1 => MCR::MC_1,
                    2 => MCR::MC_2,
                    3 => MCR::MC_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MC_0`"]
            #[inline(always)]
            pub fn is_mc_0(&self) -> bool {
                *self == MCR::MC_0
            }
            #[doc = "Checks if the value of the field is `MC_1`"]
            #[inline(always)]
            pub fn is_mc_1(&self) -> bool {
                *self == MCR::MC_1
            }
            #[doc = "Checks if the value of the field is `MC_2`"]
            #[inline(always)]
            pub fn is_mc_2(&self) -> bool {
                *self == MCR::MC_2
            }
            #[doc = "Checks if the value of the field is `MC_3`"]
            #[inline(always)]
            pub fn is_mc_3(&self) -> bool {
                *self == MCR::MC_3
            }
        }
        #[doc = "Possible values of the field `ID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR {
            #[doc = "Timer A input divider: 0 - /1"]
            ID_0,
            #[doc = "Timer A input divider: 1 - /2"]
            ID_1,
            #[doc = "Timer A input divider: 2 - /4"]
            ID_2,
            #[doc = "Timer A input divider: 3 - /8"]
            ID_3,
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDR::ID_0 => 0,
                    IDR::ID_1 => 1,
                    IDR::ID_2 => 2,
                    IDR::ID_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IDR {
                match value {
                    0 => IDR::ID_0,
                    1 => IDR::ID_1,
                    2 => IDR::ID_2,
                    3 => IDR::ID_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ID_0`"]
            #[inline(always)]
            pub fn is_id_0(&self) -> bool {
                *self == IDR::ID_0
            }
            #[doc = "Checks if the value of the field is `ID_1`"]
            #[inline(always)]
            pub fn is_id_1(&self) -> bool {
                *self == IDR::ID_1
            }
            #[doc = "Checks if the value of the field is `ID_2`"]
            #[inline(always)]
            pub fn is_id_2(&self) -> bool {
                *self == IDR::ID_2
            }
            #[doc = "Checks if the value of the field is `ID_3`"]
            #[inline(always)]
            pub fn is_id_3(&self) -> bool {
                *self == IDR::ID_3
            }
        }
        #[doc = "Possible values of the field `TASSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TASSELR {
            #[doc = "Timer A clock source select: 0 - TACLK"]
            TASSEL_0,
            #[doc = "Timer A clock source select: 1 - ACLK"]
            TASSEL_1,
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            TASSEL_2,
            #[doc = "Timer A clock source select: 3 - INCLK"]
            TASSEL_3,
        }
        impl TASSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    TASSELR::TASSEL_0 => 0,
                    TASSELR::TASSEL_1 => 1,
                    TASSELR::TASSEL_2 => 2,
                    TASSELR::TASSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> TASSELR {
                match value {
                    0 => TASSELR::TASSEL_0,
                    1 => TASSELR::TASSEL_1,
                    2 => TASSELR::TASSEL_2,
                    3 => TASSELR::TASSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TASSEL_0`"]
            #[inline(always)]
            pub fn is_tassel_0(&self) -> bool {
                *self == TASSELR::TASSEL_0
            }
            #[doc = "Checks if the value of the field is `TASSEL_1`"]
            #[inline(always)]
            pub fn is_tassel_1(&self) -> bool {
                *self == TASSELR::TASSEL_1
            }
            #[doc = "Checks if the value of the field is `TASSEL_2`"]
            #[inline(always)]
            pub fn is_tassel_2(&self) -> bool {
                *self == TASSELR::TASSEL_2
            }
            #[doc = "Checks if the value of the field is `TASSEL_3`"]
            #[inline(always)]
            pub fn is_tassel_3(&self) -> bool {
                *self == TASSELR::TASSEL_3
            }
        }
        #[doc = "Values that can be written to the field `TAIFG`"]
        pub enum TAIFGW { }
        impl TAIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TAIE`"]
        pub enum TAIEW { }
        impl TAIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TACLR`"]
        pub enum TACLRW { }
        impl TACLRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TACLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TACLRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TACLRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MC`"]
        pub enum MCW {
            #[doc = "Timer A mode control: 0 - Stop"]
            MC_0,
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            MC_1,
            #[doc = "Timer A mode control: 2 - Continous up"]
            MC_2,
            #[doc = "Timer A mode control: 3 - Up/Down"]
            MC_3,
        }
        impl MCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MCW::MC_0 => 0,
                    MCW::MC_1 => 1,
                    MCW::MC_2 => 2,
                    MCW::MC_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A mode control: 0 - Stop"]
            #[inline(always)]
            pub fn mc_0(self) -> &'a mut W {
                self.variant(MCW::MC_0)
            }
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            #[inline(always)]
            pub fn mc_1(self) -> &'a mut W {
                self.variant(MCW::MC_1)
            }
            #[doc = "Timer A mode control: 2 - Continous up"]
            #[inline(always)]
            pub fn mc_2(self) -> &'a mut W {
                self.variant(MCW::MC_2)
            }
            #[doc = "Timer A mode control: 3 - Up/Down"]
            #[inline(always)]
            pub fn mc_3(self) -> &'a mut W {
                self.variant(MCW::MC_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ID`"]
        pub enum IDW {
            #[doc = "Timer A input divider: 0 - /1"]
            ID_0,
            #[doc = "Timer A input divider: 1 - /2"]
            ID_1,
            #[doc = "Timer A input divider: 2 - /4"]
            ID_2,
            #[doc = "Timer A input divider: 3 - /8"]
            ID_3,
        }
        impl IDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDW::ID_0 => 0,
                    IDW::ID_1 => 1,
                    IDW::ID_2 => 2,
                    IDW::ID_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A input divider: 0 - /1"]
            #[inline(always)]
            pub fn id_0(self) -> &'a mut W {
                self.variant(IDW::ID_0)
            }
            #[doc = "Timer A input divider: 1 - /2"]
            #[inline(always)]
            pub fn id_1(self) -> &'a mut W {
                self.variant(IDW::ID_1)
            }
            #[doc = "Timer A input divider: 2 - /4"]
            #[inline(always)]
            pub fn id_2(self) -> &'a mut W {
                self.variant(IDW::ID_2)
            }
            #[doc = "Timer A input divider: 3 - /8"]
            #[inline(always)]
            pub fn id_3(self) -> &'a mut W {
                self.variant(IDW::ID_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TASSEL`"]
        pub enum TASSELW {
            #[doc = "Timer A clock source select: 0 - TACLK"]
            TASSEL_0,
            #[doc = "Timer A clock source select: 1 - ACLK"]
            TASSEL_1,
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            TASSEL_2,
            #[doc = "Timer A clock source select: 3 - INCLK"]
            TASSEL_3,
        }
        impl TASSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TASSELW::TASSEL_0 => 0,
                    TASSELW::TASSEL_1 => 1,
                    TASSELW::TASSEL_2 => 2,
                    TASSELW::TASSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TASSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TASSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TASSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer A clock source select: 0 - TACLK"]
            #[inline(always)]
            pub fn tassel_0(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_0)
            }
            #[doc = "Timer A clock source select: 1 - ACLK"]
            #[inline(always)]
            pub fn tassel_1(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_1)
            }
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            #[inline(always)]
            pub fn tassel_2(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_2)
            }
            #[doc = "Timer A clock source select: 3 - INCLK"]
            #[inline(always)]
            pub fn tassel_3(self) -> &'a mut W {
                self.variant(TASSELW::TASSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&self) -> TAIFGR {
                TAIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&self) -> TAIER {
                TAIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&self) -> TACLRR {
                TACLRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&self) -> MCR {
                MCR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&self) -> IDR {
                IDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&self) -> TASSELR {
                TASSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&mut self) -> _TAIFGW {
                _TAIFGW { w: self }
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&mut self) -> _TAIEW {
                _TAIEW { w: self }
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&mut self) -> _TACLRW {
                _TACLRW { w: self }
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&mut self) -> _MCW {
                _MCW { w: self }
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&mut self) -> _TASSELW {
                _TASSELW { w: self }
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare Control 0"]
    pub struct TA0CCTL0 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare Control 0"]
    pub mod ta0cctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare Control 1"]
    pub struct TA0CCTL1 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare Control 1"]
    pub mod ta0cctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare Control 2"]
    pub struct TA0CCTL2 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare Control 2"]
    pub mod ta0cctl2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCTL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CCIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIFGR {
                match value {
                    i => CCIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `COV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COVR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl COVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COVR {
                match value {
                    i => COVR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTR {
                match value {
                    i => OUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIR {
                match value {
                    i => CCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CCIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCIER {
                match value {
                    i => CCIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OUTMOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTMODR {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTMODR::OUTMOD_0 => 0,
                    OUTMODR::OUTMOD_1 => 1,
                    OUTMODR::OUTMOD_2 => 2,
                    OUTMODR::OUTMOD_3 => 3,
                    OUTMODR::OUTMOD_4 => 4,
                    OUTMODR::OUTMOD_5 => 5,
                    OUTMODR::OUTMOD_6 => 6,
                    OUTMODR::OUTMOD_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> OUTMODR {
                match value {
                    0 => OUTMODR::OUTMOD_0,
                    1 => OUTMODR::OUTMOD_1,
                    2 => OUTMODR::OUTMOD_2,
                    3 => OUTMODR::OUTMOD_3,
                    4 => OUTMODR::OUTMOD_4,
                    5 => OUTMODR::OUTMOD_5,
                    6 => OUTMODR::OUTMOD_6,
                    7 => OUTMODR::OUTMOD_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTMOD_0`"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == OUTMODR::OUTMOD_0
            }
            #[doc = "Checks if the value of the field is `OUTMOD_1`"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == OUTMODR::OUTMOD_1
            }
            #[doc = "Checks if the value of the field is `OUTMOD_2`"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == OUTMODR::OUTMOD_2
            }
            #[doc = "Checks if the value of the field is `OUTMOD_3`"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == OUTMODR::OUTMOD_3
            }
            #[doc = "Checks if the value of the field is `OUTMOD_4`"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == OUTMODR::OUTMOD_4
            }
            #[doc = "Checks if the value of the field is `OUTMOD_5`"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == OUTMODR::OUTMOD_5
            }
            #[doc = "Checks if the value of the field is `OUTMOD_6`"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == OUTMODR::OUTMOD_6
            }
            #[doc = "Checks if the value of the field is `OUTMOD_7`"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == OUTMODR::OUTMOD_7
            }
        }
        #[doc = "Possible values of the field `CAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CAPR {
                match value {
                    i => CAPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCCI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCCIR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCCIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCCIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCCIR {
                match value {
                    i => SCCIR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SCS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SCSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCSR {
                match value {
                    i => SCSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CCIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCISR {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CCISR::CCIS_0 => 0,
                    CCISR::CCIS_1 => 1,
                    CCISR::CCIS_2 => 2,
                    CCISR::CCIS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CCISR {
                match value {
                    0 => CCISR::CCIS_0,
                    1 => CCISR::CCIS_1,
                    2 => CCISR::CCIS_2,
                    3 => CCISR::CCIS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CCIS_0`"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == CCISR::CCIS_0
            }
            #[doc = "Checks if the value of the field is `CCIS_1`"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == CCISR::CCIS_1
            }
            #[doc = "Checks if the value of the field is `CCIS_2`"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == CCISR::CCIS_2
            }
            #[doc = "Checks if the value of the field is `CCIS_3`"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == CCISR::CCIS_3
            }
        }
        #[doc = "Possible values of the field `CM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMR {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMR::CM_0 => 0,
                    CMR::CM_1 => 1,
                    CMR::CM_2 => 2,
                    CMR::CM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CMR {
                match value {
                    0 => CMR::CM_0,
                    1 => CMR::CM_1,
                    2 => CMR::CM_2,
                    3 => CMR::CM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CM_0`"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == CMR::CM_0
            }
            #[doc = "Checks if the value of the field is `CM_1`"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == CMR::CM_1
            }
            #[doc = "Checks if the value of the field is `CM_2`"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == CMR::CM_2
            }
            #[doc = "Checks if the value of the field is `CM_3`"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == CMR::CM_3
            }
        }
        #[doc = "Values that can be written to the field `CCIFG`"]
        pub enum CCIFGW { }
        impl CCIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COV`"]
        pub enum COVW { }
        impl COVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW { }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCI`"]
        pub enum CCIW { }
        impl CCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIE`"]
        pub enum CCIEW { }
        impl CCIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTMOD`"]
        pub enum OUTMODW {
            #[doc = "PWM output mode: 0 - output only"]
            OUTMOD_0,
            #[doc = "PWM output mode: 1 - set"]
            OUTMOD_1,
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            OUTMOD_2,
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            OUTMOD_3,
            #[doc = "PWM output mode: 4 - toggle"]
            OUTMOD_4,
            #[doc = "PWM output mode: 5 - Reset"]
            OUTMOD_5,
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            OUTMOD_6,
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            OUTMOD_7,
        }
        impl OUTMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTMODW::OUTMOD_0 => 0,
                    OUTMODW::OUTMOD_1 => 1,
                    OUTMODW::OUTMOD_2 => 2,
                    OUTMODW::OUTMOD_3 => 3,
                    OUTMODW::OUTMOD_4 => 4,
                    OUTMODW::OUTMOD_5 => 5,
                    OUTMODW::OUTMOD_6 => 6,
                    OUTMODW::OUTMOD_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OUTMODW::OUTMOD_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP`"]
        pub enum CAPW { }
        impl CAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCCI`"]
        pub enum SCCIW { }
        impl SCCIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCCIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCS`"]
        pub enum SCSW { }
        impl SCSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCIS`"]
        pub enum CCISW {
            #[doc = "Capture input select: 0 - CCIxA"]
            CCIS_0,
            #[doc = "Capture input select: 1 - CCIxB"]
            CCIS_1,
            #[doc = "Capture input select: 2 - GND"]
            CCIS_2,
            #[doc = "Capture input select: 3 - Vcc"]
            CCIS_3,
        }
        impl CCISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CCISW::CCIS_0 => 0,
                    CCISW::CCIS_1 => 1,
                    CCISW::CCIS_2 => 2,
                    CCISW::CCIS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCISW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CCISW::CCIS_0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CCISW::CCIS_1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CCISW::CCIS_2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CCISW::CCIS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CM`"]
        pub enum CMW {
            #[doc = "Capture mode: 0 - disabled"]
            CM_0,
            #[doc = "Capture mode: 1 - pos. edge"]
            CM_1,
            #[doc = "Capture mode: 1 - neg. edge"]
            CM_2,
            #[doc = "Capture mode: 1 - both edges"]
            CM_3,
        }
        impl CMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMW::CM_0 => 0,
                    CMW::CM_1 => 1,
                    CMW::CM_2 => 2,
                    CMW::CM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CMW::CM_0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CMW::CM_1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CMW::CM_2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CMW::CM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CCIFGR {
                CCIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> COVR {
                COVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CCIR {
                CCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CCIER {
                CCIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OUTMODR {
                OUTMODR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CAPR {
                CAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> SCCIR {
                SCCIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> SCSR {
                SCSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CCISR {
                CCISR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CMR {
                CMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> _CCIFGW {
                _CCIFGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> _COVW {
                _COVW { w: self }
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> _CCIW {
                _CCIW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> _CCIEW {
                _CCIEW { w: self }
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> _OUTMODW {
                _OUTMODW { w: self }
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> _CAPW {
                _CAPW { w: self }
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> _SCCIW {
                _SCCIW { w: self }
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> _SCSW {
                _SCSW { w: self }
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> _CCISW {
                _CCISW { w: self }
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> _CMW {
                _CMW { w: self }
            }
        }
    }
    #[doc = "Timer0_A3 Counter Register"]
    pub struct TA0R {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Counter Register"]
    pub mod ta0r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0R {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare 0"]
    pub struct TA0CCR0 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare 0"]
    pub mod ta0ccr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare 1"]
    pub struct TA0CCR1 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare 1"]
    pub mod ta0ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer0_A3 Capture/Compare 2"]
    pub struct TA0CCR2 {
        register: VolatileCell<u16>,
    }
    #[doc = "Timer0_A3 Capture/Compare 2"]
    pub mod ta0ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TA0CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Timer0_A3"]
pub struct TIMER0_A3 {
    register_block: timer0_a3::RegisterBlock,
}
impl Deref for TIMER0_A3 {
    type Target = timer0_a3::RegisterBlock;
    fn deref(&self) -> &timer0_a3::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USCI_B0 I2C Mode"]
pub const USCI_B0_I2C_MODE: Peripheral<USCI_B0_I2C_MODE> =
    unsafe { Peripheral::new(104) };
#[doc = "USCI_B0 I2C Mode"]
pub mod usci_b0_i2c_mode {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USCI B0 Control Register 0"]
        pub ucb0ctl0: UCB0CTL0,
        #[doc = "0x01 - USCI B0 Control Register 1"]
        pub ucb0ctl1: UCB0CTL1,
        #[doc = "0x02 - USCI B0 Baud Rate 0"]
        pub ucb0br0: UCB0BR0,
        #[doc = "0x03 - USCI B0 Baud Rate 1"]
        pub ucb0br1: UCB0BR1,
        #[doc = "0x04 - USCI B0 I2C Interrupt Enable Register"]
        pub ucb0i2cie: UCB0I2CIE,
        #[doc = "0x05 - USCI B0 Status Register"]
        pub ucb0stat: UCB0STAT,
        #[doc = "0x06 - USCI B0 Receive Buffer"]
        pub ucb0rxbuf: UCB0RXBUF,
        #[doc = "0x07 - USCI B0 Transmit Buffer"]
        pub ucb0txbuf: UCB0TXBUF,
        _reserved0: [u8; 168usize],
        #[doc = "0xb0 - USCI B0 I2C Own Address"]
        pub ucb0i2coa: UCB0I2COA,
        #[doc = "0xb2 - USCI B0 I2C Slave Address"]
        pub ucb0i2csa: UCB0I2CSA,
    }
    #[doc = "USCI B0 Control Register 0"]
    pub struct UCB0CTL0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Control Register 0"]
    pub mod ucb0ctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0CTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSYNCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSYNCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSYNCR {
                match value {
                    i => UCSYNCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMODER {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCMODER::UCMODE_0 => 0,
                    UCMODER::UCMODE_1 => 1,
                    UCMODER::UCMODE_2 => 2,
                    UCMODER::UCMODE_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCMODER {
                match value {
                    0 => UCMODER::UCMODE_0,
                    1 => UCMODER::UCMODE_1,
                    2 => UCMODER::UCMODE_2,
                    3 => UCMODER::UCMODE_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCMODE_0`"]
            #[inline(always)]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UCMODER::UCMODE_0
            }
            #[doc = "Checks if the value of the field is `UCMODE_1`"]
            #[inline(always)]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UCMODER::UCMODE_1
            }
            #[doc = "Checks if the value of the field is `UCMODE_2`"]
            #[inline(always)]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UCMODER::UCMODE_2
            }
            #[doc = "Checks if the value of the field is `UCMODE_3`"]
            #[inline(always)]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UCMODER::UCMODE_3
            }
        }
        #[doc = "Possible values of the field `UCMST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSTR {
                match value {
                    i => UCMSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMMR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMMR {
                match value {
                    i => UCMMR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSLA10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSLA10R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSLA10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSLA10R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSLA10R {
                match value {
                    i => UCSLA10R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCA10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCA10R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCA10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCA10R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCA10R {
                match value {
                    i => UCA10R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCSYNC`"]
        pub enum UCSYNCW { }
        impl UCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSYNCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMODE`"]
        pub enum UCMODEW {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCMODEW::UCMODE_0 => 0,
                    UCMODEW::UCMODE_1 => 1,
                    UCMODEW::UCMODE_2 => 2,
                    UCMODEW::UCMODE_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Sync. Mode: USCI Mode: 0"]
            #[inline(always)]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_0)
            }
            #[doc = "Sync. Mode: USCI Mode: 1"]
            #[inline(always)]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_1)
            }
            #[doc = "Sync. Mode: USCI Mode: 2"]
            #[inline(always)]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_2)
            }
            #[doc = "Sync. Mode: USCI Mode: 3"]
            #[inline(always)]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMST`"]
        pub enum UCMSTW { }
        impl UCMSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMM`"]
        pub enum UCMMW { }
        impl UCMMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSLA10`"]
        pub enum UCSLA10W { }
        impl UCSLA10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSLA10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSLA10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSLA10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCA10`"]
        pub enum UCA10W { }
        impl UCA10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCA10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCA10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCA10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&self) -> UCSYNCR {
                UCSYNCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&self) -> UCMODER {
                UCMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&self) -> UCMSTR {
                UCMSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Multi-Master Environment"]
            #[inline(always)]
            pub fn ucmm(&self) -> UCMMR {
                UCMMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - 10-bit Slave Address Mode"]
            #[inline(always)]
            pub fn ucsla10(&self) -> UCSLA10R {
                UCSLA10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - 10-bit Address Mode"]
            #[inline(always)]
            pub fn uca10(&self) -> UCA10R {
                UCA10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&mut self) -> _UCSYNCW {
                _UCSYNCW { w: self }
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&mut self) -> _UCMODEW {
                _UCMODEW { w: self }
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&mut self) -> _UCMSTW {
                _UCMSTW { w: self }
            }
            #[doc = "Bit 5 - Multi-Master Environment"]
            #[inline(always)]
            pub fn ucmm(&mut self) -> _UCMMW {
                _UCMMW { w: self }
            }
            #[doc = "Bit 6 - 10-bit Slave Address Mode"]
            #[inline(always)]
            pub fn ucsla10(&mut self) -> _UCSLA10W {
                _UCSLA10W { w: self }
            }
            #[doc = "Bit 7 - 10-bit Address Mode"]
            #[inline(always)]
            pub fn uca10(&mut self) -> _UCA10W {
                _UCA10W { w: self }
            }
        }
    }
    #[doc = "USCI B0 Control Register 1"]
    pub struct UCB0CTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Control Register 1"]
    pub mod ucb0ctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0CTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSWRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSWRSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSWRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSWRSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSWRSTR {
                match value {
                    i => UCSWRSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTXSTT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTXSTTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTXSTTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTXSTTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTXSTTR {
                match value {
                    i => UCTXSTTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTXSTP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTXSTPR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTXSTPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTXSTPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTXSTPR {
                match value {
                    i => UCTXSTPR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTXNACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTXNACKR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTXNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTXNACKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTXNACKR {
                match value {
                    i => UCTXNACKR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCTRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCTRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCTRR {
                match value {
                    i => UCTRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSSELR {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCSSELR::UCSSEL_0 => 0,
                    UCSSELR::UCSSEL_1 => 1,
                    UCSSELR::UCSSEL_2 => 2,
                    UCSSELR::UCSSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCSSELR {
                match value {
                    0 => UCSSELR::UCSSEL_0,
                    1 => UCSSELR::UCSSEL_1,
                    2 => UCSSELR::UCSSEL_2,
                    3 => UCSSELR::UCSSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCSSEL_0`"]
            #[inline(always)]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UCSSELR::UCSSEL_0
            }
            #[doc = "Checks if the value of the field is `UCSSEL_1`"]
            #[inline(always)]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UCSSELR::UCSSEL_1
            }
            #[doc = "Checks if the value of the field is `UCSSEL_2`"]
            #[inline(always)]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UCSSELR::UCSSEL_2
            }
            #[doc = "Checks if the value of the field is `UCSSEL_3`"]
            #[inline(always)]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UCSSELR::UCSSEL_3
            }
        }
        #[doc = "Values that can be written to the field `UCSWRST`"]
        pub enum UCSWRSTW { }
        impl UCSWRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSWRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSWRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTXSTT`"]
        pub enum UCTXSTTW { }
        impl UCTXSTTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTXSTTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTXSTTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTXSTTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTXSTP`"]
        pub enum UCTXSTPW { }
        impl UCTXSTPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTXSTPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTXSTPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTXSTPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTXNACK`"]
        pub enum UCTXNACKW { }
        impl UCTXNACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTXNACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTXNACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTXNACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCTR`"]
        pub enum UCTRW { }
        impl UCTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSSEL`"]
        pub enum UCSSELW {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCSSELW::UCSSEL_0 => 0,
                    UCSSELW::UCSSEL_1 => 1,
                    UCSSELW::UCSSEL_2 => 2,
                    UCSSELW::UCSSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI 0 Clock Source: 0"]
            #[inline(always)]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_0)
            }
            #[doc = "USCI 0 Clock Source: 1"]
            #[inline(always)]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_1)
            }
            #[doc = "USCI 0 Clock Source: 2"]
            #[inline(always)]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_2)
            }
            #[doc = "USCI 0 Clock Source: 3"]
            #[inline(always)]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&self) -> UCSWRSTR {
                UCSWRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Transmit START"]
            #[inline(always)]
            pub fn uctxstt(&self) -> UCTXSTTR {
                UCTXSTTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Transmit STOP"]
            #[inline(always)]
            pub fn uctxstp(&self) -> UCTXSTPR {
                UCTXSTPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Transmit NACK"]
            #[inline(always)]
            pub fn uctxnack(&self) -> UCTXNACKR {
                UCTXNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Transmit/Receive Select/Flag"]
            #[inline(always)]
            pub fn uctr(&self) -> UCTRR {
                UCTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&self) -> UCSSELR {
                UCSSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&mut self) -> _UCSWRSTW {
                _UCSWRSTW { w: self }
            }
            #[doc = "Bit 1 - Transmit START"]
            #[inline(always)]
            pub fn uctxstt(&mut self) -> _UCTXSTTW {
                _UCTXSTTW { w: self }
            }
            #[doc = "Bit 2 - Transmit STOP"]
            #[inline(always)]
            pub fn uctxstp(&mut self) -> _UCTXSTPW {
                _UCTXSTPW { w: self }
            }
            #[doc = "Bit 3 - Transmit NACK"]
            #[inline(always)]
            pub fn uctxnack(&mut self) -> _UCTXNACKW {
                _UCTXNACKW { w: self }
            }
            #[doc = "Bit 4 - Transmit/Receive Select/Flag"]
            #[inline(always)]
            pub fn uctr(&mut self) -> _UCTRW {
                _UCTRW { w: self }
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&mut self) -> _UCSSELW {
                _UCSSELW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Baud Rate 0"]
    pub struct UCB0BR0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Baud Rate 0"]
    pub mod ucb0br0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0BR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 Baud Rate 1"]
    pub struct UCB0BR1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Baud Rate 1"]
    pub mod ucb0br1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0BR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 I2C Interrupt Enable Register"]
    pub struct UCB0I2CIE {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 I2C Interrupt Enable Register"]
    pub mod ucb0i2cie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0I2CIE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCALIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCALIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCALIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCALIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCALIER {
                match value {
                    i => UCALIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSTTIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSTTIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSTTIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSTTIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSTTIER {
                match value {
                    i => UCSTTIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSTPIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSTPIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSTPIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSTPIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSTPIER {
                match value {
                    i => UCSTPIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCNACKIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCNACKIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCNACKIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCNACKIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCNACKIER {
                match value {
                    i => UCNACKIER::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCALIE`"]
        pub enum UCALIEW { }
        impl UCALIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCALIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCALIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCALIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSTTIE`"]
        pub enum UCSTTIEW { }
        impl UCSTTIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSTTIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSTTIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSTTIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSTPIE`"]
        pub enum UCSTPIEW { }
        impl UCSTPIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSTPIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSTPIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSTPIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCNACKIE`"]
        pub enum UCNACKIEW { }
        impl UCNACKIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCNACKIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCNACKIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCNACKIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Arbitration Lost interrupt enable"]
            #[inline(always)]
            pub fn ucalie(&self) -> UCALIER {
                UCALIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - START Condition interrupt enable"]
            #[inline(always)]
            pub fn ucsttie(&self) -> UCSTTIER {
                UCSTTIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - STOP Condition interrupt enable"]
            #[inline(always)]
            pub fn ucstpie(&self) -> UCSTPIER {
                UCSTPIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - NACK Condition interrupt enable"]
            #[inline(always)]
            pub fn ucnackie(&self) -> UCNACKIER {
                UCNACKIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Arbitration Lost interrupt enable"]
            #[inline(always)]
            pub fn ucalie(&mut self) -> _UCALIEW {
                _UCALIEW { w: self }
            }
            #[doc = "Bit 1 - START Condition interrupt enable"]
            #[inline(always)]
            pub fn ucsttie(&mut self) -> _UCSTTIEW {
                _UCSTTIEW { w: self }
            }
            #[doc = "Bit 2 - STOP Condition interrupt enable"]
            #[inline(always)]
            pub fn ucstpie(&mut self) -> _UCSTPIEW {
                _UCSTPIEW { w: self }
            }
            #[doc = "Bit 3 - NACK Condition interrupt enable"]
            #[inline(always)]
            pub fn ucnackie(&mut self) -> _UCNACKIEW {
                _UCNACKIEW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Status Register"]
    pub struct UCB0STAT {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Status Register"]
    pub mod ucb0stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCALIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCALIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCALIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCALIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCALIFGR {
                match value {
                    i => UCALIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSTTIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSTTIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSTTIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSTTIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSTTIFGR {
                match value {
                    i => UCSTTIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSTPIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSTPIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSTPIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSTPIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSTPIFGR {
                match value {
                    i => UCSTPIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCNACKIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCNACKIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCNACKIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCNACKIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCNACKIFGR {
                match value {
                    i => UCNACKIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCBBUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBBUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBBUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBBUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBBUSYR {
                match value {
                    i => UCBBUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCGC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCGCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCGCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCGCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCGCR {
                match value {
                    i => UCGCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSCLLOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSCLLOWR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSCLLOWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSCLLOWR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSCLLOWR {
                match value {
                    i => UCSCLLOWR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCLISTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCLISTENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCLISTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCLISTENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCLISTENR {
                match value {
                    i => UCLISTENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCALIFG`"]
        pub enum UCALIFGW { }
        impl UCALIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCALIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCALIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCALIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSTTIFG`"]
        pub enum UCSTTIFGW { }
        impl UCSTTIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSTTIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSTTIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSTTIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSTPIFG`"]
        pub enum UCSTPIFGW { }
        impl UCSTPIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSTPIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSTPIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSTPIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCNACKIFG`"]
        pub enum UCNACKIFGW { }
        impl UCNACKIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCNACKIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCNACKIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCNACKIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCBBUSY`"]
        pub enum UCBBUSYW { }
        impl UCBBUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBBUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBBUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBBUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCGC`"]
        pub enum UCGCW { }
        impl UCGCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCGCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCGCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCGCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSCLLOW`"]
        pub enum UCSCLLOWW { }
        impl UCSCLLOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSCLLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSCLLOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSCLLOWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCLISTEN`"]
        pub enum UCLISTENW { }
        impl UCLISTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCLISTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCLISTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCLISTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Arbitration Lost interrupt Flag"]
            #[inline(always)]
            pub fn ucalifg(&self) -> UCALIFGR {
                UCALIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - START Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucsttifg(&self) -> UCSTTIFGR {
                UCSTTIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - STOP Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucstpifg(&self) -> UCSTPIFGR {
                UCSTPIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - NAK Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucnackifg(&self) -> UCNACKIFGR {
                UCNACKIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Bus Busy Flag"]
            #[inline(always)]
            pub fn ucbbusy(&self) -> UCBBUSYR {
                UCBBUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - General Call address received Flag"]
            #[inline(always)]
            pub fn ucgc(&self) -> UCGCR {
                UCGCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - SCL low"]
            #[inline(always)]
            pub fn ucscllow(&self) -> UCSCLLOWR {
                UCSCLLOWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&self) -> UCLISTENR {
                UCLISTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Arbitration Lost interrupt Flag"]
            #[inline(always)]
            pub fn ucalifg(&mut self) -> _UCALIFGW {
                _UCALIFGW { w: self }
            }
            #[doc = "Bit 1 - START Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucsttifg(&mut self) -> _UCSTTIFGW {
                _UCSTTIFGW { w: self }
            }
            #[doc = "Bit 2 - STOP Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucstpifg(&mut self) -> _UCSTPIFGW {
                _UCSTPIFGW { w: self }
            }
            #[doc = "Bit 3 - NAK Condition interrupt Flag"]
            #[inline(always)]
            pub fn ucnackifg(&mut self) -> _UCNACKIFGW {
                _UCNACKIFGW { w: self }
            }
            #[doc = "Bit 4 - Bus Busy Flag"]
            #[inline(always)]
            pub fn ucbbusy(&mut self) -> _UCBBUSYW {
                _UCBBUSYW { w: self }
            }
            #[doc = "Bit 5 - General Call address received Flag"]
            #[inline(always)]
            pub fn ucgc(&mut self) -> _UCGCW {
                _UCGCW { w: self }
            }
            #[doc = "Bit 6 - SCL low"]
            #[inline(always)]
            pub fn ucscllow(&mut self) -> _UCSCLLOWW {
                _UCSCLLOWW { w: self }
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&mut self) -> _UCLISTENW {
                _UCLISTENW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Receive Buffer"]
    pub struct UCB0RXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Receive Buffer"]
    pub mod ucb0rxbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0RXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 Transmit Buffer"]
    pub struct UCB0TXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Transmit Buffer"]
    pub mod ucb0txbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0TXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 I2C Own Address"]
    pub struct UCB0I2COA {
        register: VolatileCell<u16>,
    }
    #[doc = "USCI B0 I2C Own Address"]
    pub mod ucb0i2coa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::UCB0I2COA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCOA0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA0R {
                match value {
                    i => UCOA0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA1R {
                match value {
                    i => UCOA1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA2R {
                match value {
                    i => UCOA2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA3R {
                match value {
                    i => UCOA3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA4R {
                match value {
                    i => UCOA4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA5R {
                match value {
                    i => UCOA5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA6R {
                match value {
                    i => UCOA6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA7R {
                match value {
                    i => UCOA7R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA8R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA8R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA8R {
                match value {
                    i => UCOA8R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOA9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOA9R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOA9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOA9R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOA9R {
                match value {
                    i => UCOA9R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCGCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCGCENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCGCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCGCENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCGCENR {
                match value {
                    i => UCGCENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCOA0`"]
        pub enum UCOA0W { }
        impl UCOA0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA1`"]
        pub enum UCOA1W { }
        impl UCOA1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA2`"]
        pub enum UCOA2W { }
        impl UCOA2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA3`"]
        pub enum UCOA3W { }
        impl UCOA3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA4`"]
        pub enum UCOA4W { }
        impl UCOA4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA5`"]
        pub enum UCOA5W { }
        impl UCOA5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA6`"]
        pub enum UCOA6W { }
        impl UCOA6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA7`"]
        pub enum UCOA7W { }
        impl UCOA7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA8`"]
        pub enum UCOA8W { }
        impl UCOA8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOA9`"]
        pub enum UCOA9W { }
        impl UCOA9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOA9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOA9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOA9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCGCEN`"]
        pub enum UCGCENW { }
        impl UCGCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCGCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCGCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCGCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - I2C Own Address 0"]
            #[inline(always)]
            pub fn ucoa0(&self) -> UCOA0R {
                UCOA0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - I2C Own Address 1"]
            #[inline(always)]
            pub fn ucoa1(&self) -> UCOA1R {
                UCOA1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - I2C Own Address 2"]
            #[inline(always)]
            pub fn ucoa2(&self) -> UCOA2R {
                UCOA2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - I2C Own Address 3"]
            #[inline(always)]
            pub fn ucoa3(&self) -> UCOA3R {
                UCOA3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - I2C Own Address 4"]
            #[inline(always)]
            pub fn ucoa4(&self) -> UCOA4R {
                UCOA4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - I2C Own Address 5"]
            #[inline(always)]
            pub fn ucoa5(&self) -> UCOA5R {
                UCOA5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - I2C Own Address 6"]
            #[inline(always)]
            pub fn ucoa6(&self) -> UCOA6R {
                UCOA6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - I2C Own Address 7"]
            #[inline(always)]
            pub fn ucoa7(&self) -> UCOA7R {
                UCOA7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 8 - I2C Own Address 8"]
            #[inline(always)]
            pub fn ucoa8(&self) -> UCOA8R {
                UCOA8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 9 - I2C Own Address 9"]
            #[inline(always)]
            pub fn ucoa9(&self) -> UCOA9R {
                UCOA9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 15 - I2C General Call enable"]
            #[inline(always)]
            pub fn ucgcen(&self) -> UCGCENR {
                UCGCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - I2C Own Address 0"]
            #[inline(always)]
            pub fn ucoa0(&mut self) -> _UCOA0W {
                _UCOA0W { w: self }
            }
            #[doc = "Bit 1 - I2C Own Address 1"]
            #[inline(always)]
            pub fn ucoa1(&mut self) -> _UCOA1W {
                _UCOA1W { w: self }
            }
            #[doc = "Bit 2 - I2C Own Address 2"]
            #[inline(always)]
            pub fn ucoa2(&mut self) -> _UCOA2W {
                _UCOA2W { w: self }
            }
            #[doc = "Bit 3 - I2C Own Address 3"]
            #[inline(always)]
            pub fn ucoa3(&mut self) -> _UCOA3W {
                _UCOA3W { w: self }
            }
            #[doc = "Bit 4 - I2C Own Address 4"]
            #[inline(always)]
            pub fn ucoa4(&mut self) -> _UCOA4W {
                _UCOA4W { w: self }
            }
            #[doc = "Bit 5 - I2C Own Address 5"]
            #[inline(always)]
            pub fn ucoa5(&mut self) -> _UCOA5W {
                _UCOA5W { w: self }
            }
            #[doc = "Bit 6 - I2C Own Address 6"]
            #[inline(always)]
            pub fn ucoa6(&mut self) -> _UCOA6W {
                _UCOA6W { w: self }
            }
            #[doc = "Bit 7 - I2C Own Address 7"]
            #[inline(always)]
            pub fn ucoa7(&mut self) -> _UCOA7W {
                _UCOA7W { w: self }
            }
            #[doc = "Bit 8 - I2C Own Address 8"]
            #[inline(always)]
            pub fn ucoa8(&mut self) -> _UCOA8W {
                _UCOA8W { w: self }
            }
            #[doc = "Bit 9 - I2C Own Address 9"]
            #[inline(always)]
            pub fn ucoa9(&mut self) -> _UCOA9W {
                _UCOA9W { w: self }
            }
            #[doc = "Bit 15 - I2C General Call enable"]
            #[inline(always)]
            pub fn ucgcen(&mut self) -> _UCGCENW {
                _UCGCENW { w: self }
            }
        }
    }
    #[doc = "USCI B0 I2C Slave Address"]
    pub struct UCB0I2CSA {
        register: VolatileCell<u16>,
    }
    #[doc = "USCI B0 I2C Slave Address"]
    pub mod ucb0i2csa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::UCB0I2CSA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSA0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA0R {
                match value {
                    i => UCSA0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA1R {
                match value {
                    i => UCSA1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA2R {
                match value {
                    i => UCSA2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA3R {
                match value {
                    i => UCSA3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA4R {
                match value {
                    i => UCSA4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA5R {
                match value {
                    i => UCSA5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA6R {
                match value {
                    i => UCSA6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA7R {
                match value {
                    i => UCSA7R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA8R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA8R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA8R {
                match value {
                    i => UCSA8R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSA9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSA9R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSA9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSA9R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSA9R {
                match value {
                    i => UCSA9R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCSA0`"]
        pub enum UCSA0W { }
        impl UCSA0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA1`"]
        pub enum UCSA1W { }
        impl UCSA1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA2`"]
        pub enum UCSA2W { }
        impl UCSA2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA3`"]
        pub enum UCSA3W { }
        impl UCSA3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA4`"]
        pub enum UCSA4W { }
        impl UCSA4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA5`"]
        pub enum UCSA5W { }
        impl UCSA5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA6`"]
        pub enum UCSA6W { }
        impl UCSA6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA7`"]
        pub enum UCSA7W { }
        impl UCSA7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA8`"]
        pub enum UCSA8W { }
        impl UCSA8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSA9`"]
        pub enum UCSA9W { }
        impl UCSA9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSA9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSA9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSA9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - I2C Slave Address 0"]
            #[inline(always)]
            pub fn ucsa0(&self) -> UCSA0R {
                UCSA0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - I2C Slave Address 1"]
            #[inline(always)]
            pub fn ucsa1(&self) -> UCSA1R {
                UCSA1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - I2C Slave Address 2"]
            #[inline(always)]
            pub fn ucsa2(&self) -> UCSA2R {
                UCSA2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - I2C Slave Address 3"]
            #[inline(always)]
            pub fn ucsa3(&self) -> UCSA3R {
                UCSA3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - I2C Slave Address 4"]
            #[inline(always)]
            pub fn ucsa4(&self) -> UCSA4R {
                UCSA4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - I2C Slave Address 5"]
            #[inline(always)]
            pub fn ucsa5(&self) -> UCSA5R {
                UCSA5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - I2C Slave Address 6"]
            #[inline(always)]
            pub fn ucsa6(&self) -> UCSA6R {
                UCSA6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - I2C Slave Address 7"]
            #[inline(always)]
            pub fn ucsa7(&self) -> UCSA7R {
                UCSA7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 8 - I2C Slave Address 8"]
            #[inline(always)]
            pub fn ucsa8(&self) -> UCSA8R {
                UCSA8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 9 - I2C Slave Address 9"]
            #[inline(always)]
            pub fn ucsa9(&self) -> UCSA9R {
                UCSA9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - I2C Slave Address 0"]
            #[inline(always)]
            pub fn ucsa0(&mut self) -> _UCSA0W {
                _UCSA0W { w: self }
            }
            #[doc = "Bit 1 - I2C Slave Address 1"]
            #[inline(always)]
            pub fn ucsa1(&mut self) -> _UCSA1W {
                _UCSA1W { w: self }
            }
            #[doc = "Bit 2 - I2C Slave Address 2"]
            #[inline(always)]
            pub fn ucsa2(&mut self) -> _UCSA2W {
                _UCSA2W { w: self }
            }
            #[doc = "Bit 3 - I2C Slave Address 3"]
            #[inline(always)]
            pub fn ucsa3(&mut self) -> _UCSA3W {
                _UCSA3W { w: self }
            }
            #[doc = "Bit 4 - I2C Slave Address 4"]
            #[inline(always)]
            pub fn ucsa4(&mut self) -> _UCSA4W {
                _UCSA4W { w: self }
            }
            #[doc = "Bit 5 - I2C Slave Address 5"]
            #[inline(always)]
            pub fn ucsa5(&mut self) -> _UCSA5W {
                _UCSA5W { w: self }
            }
            #[doc = "Bit 6 - I2C Slave Address 6"]
            #[inline(always)]
            pub fn ucsa6(&mut self) -> _UCSA6W {
                _UCSA6W { w: self }
            }
            #[doc = "Bit 7 - I2C Slave Address 7"]
            #[inline(always)]
            pub fn ucsa7(&mut self) -> _UCSA7W {
                _UCSA7W { w: self }
            }
            #[doc = "Bit 8 - I2C Slave Address 8"]
            #[inline(always)]
            pub fn ucsa8(&mut self) -> _UCSA8W {
                _UCSA8W { w: self }
            }
            #[doc = "Bit 9 - I2C Slave Address 9"]
            #[inline(always)]
            pub fn ucsa9(&mut self) -> _UCSA9W {
                _UCSA9W { w: self }
            }
        }
    }
}
#[doc = "USCI_B0 I2C Mode"]
pub struct USCI_B0_I2C_MODE {
    register_block: usci_b0_i2c_mode::RegisterBlock,
}
impl Deref for USCI_B0_I2C_MODE {
    type Target = usci_b0_i2c_mode::RegisterBlock;
    fn deref(&self) -> &usci_b0_i2c_mode::RegisterBlock {
        &self.register_block
    }
}
#[doc = "TLV Calibration Data"]
pub const TLV_CALIBRATION_DATA: Peripheral<TLV_CALIBRATION_DATA> =
    unsafe { Peripheral::new(4288) };
#[doc = "TLV Calibration Data"]
pub mod tlv_calibration_data {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - TLV CHECK SUM"]
        pub tlv_checksum: TLV_CHECKSUM,
        _reserved0: [u8; 24usize],
        #[doc = "0x1a - TLV ADC10_1 TAG"]
        pub tlv_adc10_1_tag: TLV_ADC10_1_TAG,
        #[doc = "0x1b - TLV ADC10_1 LEN"]
        pub tlv_adc10_1_len: TLV_ADC10_1_LEN,
        _reserved1: [u8; 26usize],
        #[doc = "0x36 - TLV TAG_DCO30 TAG"]
        pub tlv_dco_30_tag: TLV_DCO_30_TAG,
        #[doc = "0x37 - TLV TAG_DCO30 LEN"]
        pub tlv_dco_30_len: TLV_DCO_30_LEN,
    }
    #[doc = "TLV ADC10_1 TAG"]
    pub struct TLV_ADC10_1_TAG {
        register: VolatileCell<u8>,
    }
    #[doc = "TLV ADC10_1 TAG"]
    pub mod tlv_adc10_1_tag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::TLV_ADC10_1_TAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "TLV ADC10_1 LEN"]
    pub struct TLV_ADC10_1_LEN {
        register: VolatileCell<u8>,
    }
    #[doc = "TLV ADC10_1 LEN"]
    pub mod tlv_adc10_1_len {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::TLV_ADC10_1_LEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "TLV TAG_DCO30 TAG"]
    pub struct TLV_DCO_30_TAG {
        register: VolatileCell<u8>,
    }
    #[doc = "TLV TAG_DCO30 TAG"]
    pub mod tlv_dco_30_tag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::TLV_DCO_30_TAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "TLV TAG_DCO30 LEN"]
    pub struct TLV_DCO_30_LEN {
        register: VolatileCell<u8>,
    }
    #[doc = "TLV TAG_DCO30 LEN"]
    pub mod tlv_dco_30_len {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::TLV_DCO_30_LEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "TLV CHECK SUM"]
    pub struct TLV_CHECKSUM {
        register: VolatileCell<u16>,
    }
    #[doc = "TLV CHECK SUM"]
    pub mod tlv_checksum {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::TLV_CHECKSUM {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "TLV Calibration Data"]
pub struct TLV_CALIBRATION_DATA {
    register_block: tlv_calibration_data::RegisterBlock,
}
impl Deref for TLV_CALIBRATION_DATA {
    type Target = tlv_calibration_data::RegisterBlock;
    fn deref(&self) -> &tlv_calibration_data::RegisterBlock {
        &self.register_block
    }
}
#[doc = "ADC10"]
pub const ADC10: Peripheral<ADC10> = unsafe { Peripheral::new(72) };
#[doc = "ADC10"]
pub mod adc10 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - ADC10 Data Transfer Control 0"]
        pub adc10dtc0: ADC10DTC0,
        #[doc = "0x01 - ADC10 Data Transfer Control 1"]
        pub adc10dtc1: ADC10DTC1,
        #[doc = "0x02 - ADC10 Analog Enable 0"]
        pub adc10ae0: ADC10AE0,
        _reserved0: [u8; 357usize],
        #[doc = "0x168 - ADC10 Control 0"]
        pub adc10ctl0: ADC10CTL0,
        #[doc = "0x16a - ADC10 Control 1"]
        pub adc10ctl1: ADC10CTL1,
        #[doc = "0x16c - ADC10 Memory"]
        pub adc10mem: ADC10MEM,
        _reserved1: [u8; 6usize],
        #[doc = "0x174 - ADC10 Data Transfer Start Address"]
        pub adc10sa: ADC10SA,
    }
    #[doc = "ADC10 Data Transfer Control 0"]
    pub struct ADC10DTC0 {
        register: VolatileCell<u8>,
    }
    #[doc = "ADC10 Data Transfer Control 0"]
    pub mod adc10dtc0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::ADC10DTC0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ADC10FETCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10FETCHR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10FETCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10FETCHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10FETCHR {
                match value {
                    i => ADC10FETCHR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10B1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10B1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10B1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10B1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10B1R {
                match value {
                    i => ADC10B1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10CT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10CTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10CTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10CTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10CTR {
                match value {
                    i => ADC10CTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10TB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10TBR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10TBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10TBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10TBR {
                match value {
                    i => ADC10TBR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `ADC10FETCH`"]
        pub enum ADC10FETCHW { }
        impl ADC10FETCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10FETCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10FETCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10FETCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10B1`"]
        pub enum ADC10B1W { }
        impl ADC10B1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10B1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10B1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10B1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10CT`"]
        pub enum ADC10CTW { }
        impl ADC10CTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10CTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10CTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10CTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10TB`"]
        pub enum ADC10TBW { }
        impl ADC10TBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10TBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10TBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10TBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - This bit should normally be reset"]
            #[inline(always)]
            pub fn adc10fetch(&self) -> ADC10FETCHR {
                ADC10FETCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - ADC10 block one"]
            #[inline(always)]
            pub fn adc10b1(&self) -> ADC10B1R {
                ADC10B1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - ADC10 continuous transfer"]
            #[inline(always)]
            pub fn adc10ct(&self) -> ADC10CTR {
                ADC10CTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - ADC10 two-block mode"]
            #[inline(always)]
            pub fn adc10tb(&self) -> ADC10TBR {
                ADC10TBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - This bit should normally be reset"]
            #[inline(always)]
            pub fn adc10fetch(&mut self) -> _ADC10FETCHW {
                _ADC10FETCHW { w: self }
            }
            #[doc = "Bit 1 - ADC10 block one"]
            #[inline(always)]
            pub fn adc10b1(&mut self) -> _ADC10B1W {
                _ADC10B1W { w: self }
            }
            #[doc = "Bit 2 - ADC10 continuous transfer"]
            #[inline(always)]
            pub fn adc10ct(&mut self) -> _ADC10CTW {
                _ADC10CTW { w: self }
            }
            #[doc = "Bit 3 - ADC10 two-block mode"]
            #[inline(always)]
            pub fn adc10tb(&mut self) -> _ADC10TBW {
                _ADC10TBW { w: self }
            }
        }
    }
    #[doc = "ADC10 Data Transfer Control 1"]
    pub struct ADC10DTC1 {
        register: VolatileCell<u8>,
    }
    #[doc = "ADC10 Data Transfer Control 1"]
    pub mod adc10dtc1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::ADC10DTC1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ADC10 Analog Enable 0"]
    pub struct ADC10AE0 {
        register: VolatileCell<u8>,
    }
    #[doc = "ADC10 Analog Enable 0"]
    pub mod adc10ae0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::ADC10AE0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ADC10 Control 0"]
    pub struct ADC10CTL0 {
        register: VolatileCell<u16>,
    }
    #[doc = "ADC10 Control 0"]
    pub mod adc10ctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::ADC10CTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ADC10SC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10SCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10SCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10SCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10SCR {
                match value {
                    i => ADC10SCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ENC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ENCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENCR {
                match value {
                    i => ENCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10IFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10IFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10IFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10IFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10IFGR {
                match value {
                    i => ADC10IFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10IE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10IER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10IER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10IER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10IER {
                match value {
                    i => ADC10IER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10ON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10ONR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10ONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10ONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10ONR {
                match value {
                    i => ADC10ONR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `REFON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFONR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl REFONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    REFONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> REFONR {
                match value {
                    i => REFONR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `REF2_5V`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REF2_5VR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl REF2_5VR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    REF2_5VR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> REF2_5VR {
                match value {
                    i => REF2_5VR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MSC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MSCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSCR {
                match value {
                    i => MSCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `REFBURST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFBURSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl REFBURSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    REFBURSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> REFBURSTR {
                match value {
                    i => REFBURSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `REFOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFOUTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl REFOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    REFOUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> REFOUTR {
                match value {
                    i => REFOUTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10SR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10SRR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10SRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10SRR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10SRR {
                match value {
                    i => ADC10SRR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10SHT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10SHTR {
            #[doc = "4 x ADC10CLKs"]
            ADC10SHT_0,
            #[doc = "8 x ADC10CLKs"]
            ADC10SHT_1,
            #[doc = "16 x ADC10CLKs"]
            ADC10SHT_2,
            #[doc = "64 x ADC10CLKs"]
            ADC10SHT_3,
        }
        impl ADC10SHTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADC10SHTR::ADC10SHT_0 => 0,
                    ADC10SHTR::ADC10SHT_1 => 1,
                    ADC10SHTR::ADC10SHT_2 => 2,
                    ADC10SHTR::ADC10SHT_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> ADC10SHTR {
                match value {
                    0 => ADC10SHTR::ADC10SHT_0,
                    1 => ADC10SHTR::ADC10SHT_1,
                    2 => ADC10SHTR::ADC10SHT_2,
                    3 => ADC10SHTR::ADC10SHT_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ADC10SHT_0`"]
            #[inline(always)]
            pub fn is_adc10sht_0(&self) -> bool {
                *self == ADC10SHTR::ADC10SHT_0
            }
            #[doc = "Checks if the value of the field is `ADC10SHT_1`"]
            #[inline(always)]
            pub fn is_adc10sht_1(&self) -> bool {
                *self == ADC10SHTR::ADC10SHT_1
            }
            #[doc = "Checks if the value of the field is `ADC10SHT_2`"]
            #[inline(always)]
            pub fn is_adc10sht_2(&self) -> bool {
                *self == ADC10SHTR::ADC10SHT_2
            }
            #[doc = "Checks if the value of the field is `ADC10SHT_3`"]
            #[inline(always)]
            pub fn is_adc10sht_3(&self) -> bool {
                *self == ADC10SHTR::ADC10SHT_3
            }
        }
        #[doc = "Possible values of the field `SREF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SREFR {
            #[doc = "VR+ = AVCC and VR- = AVSS"]
            SREF_0,
            #[doc = "VR+ = VREF+ and VR- = AVSS"]
            SREF_1,
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            SREF_2,
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            SREF_3,
            #[doc = "VR+ = AVCC and VR- = VREF-/VEREF-"]
            SREF_4,
            #[doc = "VR+ = VREF+ and VR- = VREF-/VEREF-"]
            SREF_5,
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            SREF_6,
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            SREF_7,
        }
        impl SREFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SREFR::SREF_0 => 0,
                    SREFR::SREF_1 => 1,
                    SREFR::SREF_2 => 2,
                    SREFR::SREF_3 => 3,
                    SREFR::SREF_4 => 4,
                    SREFR::SREF_5 => 5,
                    SREFR::SREF_6 => 6,
                    SREFR::SREF_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SREFR {
                match value {
                    0 => SREFR::SREF_0,
                    1 => SREFR::SREF_1,
                    2 => SREFR::SREF_2,
                    3 => SREFR::SREF_3,
                    4 => SREFR::SREF_4,
                    5 => SREFR::SREF_5,
                    6 => SREFR::SREF_6,
                    7 => SREFR::SREF_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SREF_0`"]
            #[inline(always)]
            pub fn is_sref_0(&self) -> bool {
                *self == SREFR::SREF_0
            }
            #[doc = "Checks if the value of the field is `SREF_1`"]
            #[inline(always)]
            pub fn is_sref_1(&self) -> bool {
                *self == SREFR::SREF_1
            }
            #[doc = "Checks if the value of the field is `SREF_2`"]
            #[inline(always)]
            pub fn is_sref_2(&self) -> bool {
                *self == SREFR::SREF_2
            }
            #[doc = "Checks if the value of the field is `SREF_3`"]
            #[inline(always)]
            pub fn is_sref_3(&self) -> bool {
                *self == SREFR::SREF_3
            }
            #[doc = "Checks if the value of the field is `SREF_4`"]
            #[inline(always)]
            pub fn is_sref_4(&self) -> bool {
                *self == SREFR::SREF_4
            }
            #[doc = "Checks if the value of the field is `SREF_5`"]
            #[inline(always)]
            pub fn is_sref_5(&self) -> bool {
                *self == SREFR::SREF_5
            }
            #[doc = "Checks if the value of the field is `SREF_6`"]
            #[inline(always)]
            pub fn is_sref_6(&self) -> bool {
                *self == SREFR::SREF_6
            }
            #[doc = "Checks if the value of the field is `SREF_7`"]
            #[inline(always)]
            pub fn is_sref_7(&self) -> bool {
                *self == SREFR::SREF_7
            }
        }
        #[doc = "Values that can be written to the field `ADC10SC`"]
        pub enum ADC10SCW { }
        impl ADC10SCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10SCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10SCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10SCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENC`"]
        pub enum ENCW { }
        impl ENCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10IFG`"]
        pub enum ADC10IFGW { }
        impl ADC10IFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10IFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10IFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10IFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10IE`"]
        pub enum ADC10IEW { }
        impl ADC10IEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10ON`"]
        pub enum ADC10ONW { }
        impl ADC10ONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10ONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10ONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10ONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFON`"]
        pub enum REFONW { }
        impl REFONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REF2_5V`"]
        pub enum REF2_5VW { }
        impl REF2_5VW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REF2_5VW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REF2_5VW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REF2_5VW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSC`"]
        pub enum MSCW { }
        impl MSCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFBURST`"]
        pub enum REFBURSTW { }
        impl REFBURSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFBURSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFBURSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFBURSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFOUT`"]
        pub enum REFOUTW { }
        impl REFOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10SR`"]
        pub enum ADC10SRW { }
        impl ADC10SRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10SRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10SRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10SRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10SHT`"]
        pub enum ADC10SHTW {
            #[doc = "4 x ADC10CLKs"]
            ADC10SHT_0,
            #[doc = "8 x ADC10CLKs"]
            ADC10SHT_1,
            #[doc = "16 x ADC10CLKs"]
            ADC10SHT_2,
            #[doc = "64 x ADC10CLKs"]
            ADC10SHT_3,
        }
        impl ADC10SHTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADC10SHTW::ADC10SHT_0 => 0,
                    ADC10SHTW::ADC10SHT_1 => 1,
                    ADC10SHTW::ADC10SHT_2 => 2,
                    ADC10SHTW::ADC10SHT_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10SHTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10SHTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10SHTW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "4 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_0(self) -> &'a mut W {
                self.variant(ADC10SHTW::ADC10SHT_0)
            }
            #[doc = "8 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_1(self) -> &'a mut W {
                self.variant(ADC10SHTW::ADC10SHT_1)
            }
            #[doc = "16 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_2(self) -> &'a mut W {
                self.variant(ADC10SHTW::ADC10SHT_2)
            }
            #[doc = "64 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_3(self) -> &'a mut W {
                self.variant(ADC10SHTW::ADC10SHT_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SREF`"]
        pub enum SREFW {
            #[doc = "VR+ = AVCC and VR- = AVSS"]
            SREF_0,
            #[doc = "VR+ = VREF+ and VR- = AVSS"]
            SREF_1,
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            SREF_2,
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            SREF_3,
            #[doc = "VR+ = AVCC and VR- = VREF-/VEREF-"]
            SREF_4,
            #[doc = "VR+ = VREF+ and VR- = VREF-/VEREF-"]
            SREF_5,
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            SREF_6,
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            SREF_7,
        }
        impl SREFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SREFW::SREF_0 => 0,
                    SREFW::SREF_1 => 1,
                    SREFW::SREF_2 => 2,
                    SREFW::SREF_3 => 3,
                    SREFW::SREF_4 => 4,
                    SREFW::SREF_5 => 5,
                    SREFW::SREF_6 => 6,
                    SREFW::SREF_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SREFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SREFW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "VR+ = AVCC and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_0(self) -> &'a mut W {
                self.variant(SREFW::SREF_0)
            }
            #[doc = "VR+ = VREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_1(self) -> &'a mut W {
                self.variant(SREFW::SREF_1)
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_2(self) -> &'a mut W {
                self.variant(SREFW::SREF_2)
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_3(self) -> &'a mut W {
                self.variant(SREFW::SREF_3)
            }
            #[doc = "VR+ = AVCC and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_4(self) -> &'a mut W {
                self.variant(SREFW::SREF_4)
            }
            #[doc = "VR+ = VREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_5(self) -> &'a mut W {
                self.variant(SREFW::SREF_5)
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_6(self) -> &'a mut W {
                self.variant(SREFW::SREF_6)
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_7(self) -> &'a mut W {
                self.variant(SREFW::SREF_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - ADC10 Start Conversion"]
            #[inline(always)]
            pub fn adc10sc(&self) -> ADC10SCR {
                ADC10SCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 1 - ADC10 Enable Conversion"]
            #[inline(always)]
            pub fn enc(&self) -> ENCR {
                ENCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 2 - ADC10 Interrupt Flag"]
            #[inline(always)]
            pub fn adc10ifg(&self) -> ADC10IFGR {
                ADC10IFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 3 - ADC10 Interrupt Enalbe"]
            #[inline(always)]
            pub fn adc10ie(&self) -> ADC10IER {
                ADC10IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 4 - ADC10 On/Enable"]
            #[inline(always)]
            pub fn adc10on(&self) -> ADC10ONR {
                ADC10ONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 5 - ADC10 Reference on"]
            #[inline(always)]
            pub fn refon(&self) -> REFONR {
                REFONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 6 - ADC10 Ref 0:1.5V / 1:2.5V"]
            #[inline(always)]
            pub fn ref2_5v(&self) -> REF2_5VR {
                REF2_5VR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 7 - ADC10 Multiple SampleConversion"]
            #[inline(always)]
            pub fn msc(&self) -> MSCR {
                MSCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 8 - ADC10 Reference Burst Mode"]
            #[inline(always)]
            pub fn refburst(&self) -> REFBURSTR {
                REFBURSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 9 - ADC10 Enalbe output of Ref."]
            #[inline(always)]
            pub fn refout(&self) -> REFOUTR {
                REFOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 10 - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
            #[inline(always)]
            pub fn adc10sr(&self) -> ADC10SRR {
                ADC10SRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 11:12 - ADC10 Sample Hold Select Bit: 0"]
            #[inline(always)]
            pub fn adc10sht(&self) -> ADC10SHTR {
                ADC10SHTR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 13:15 - ADC10 Reference Select Bit: 0"]
            #[inline(always)]
            pub fn sref(&self) -> SREFR {
                SREFR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ADC10 Start Conversion"]
            #[inline(always)]
            pub fn adc10sc(&mut self) -> _ADC10SCW {
                _ADC10SCW { w: self }
            }
            #[doc = "Bit 1 - ADC10 Enable Conversion"]
            #[inline(always)]
            pub fn enc(&mut self) -> _ENCW {
                _ENCW { w: self }
            }
            #[doc = "Bit 2 - ADC10 Interrupt Flag"]
            #[inline(always)]
            pub fn adc10ifg(&mut self) -> _ADC10IFGW {
                _ADC10IFGW { w: self }
            }
            #[doc = "Bit 3 - ADC10 Interrupt Enalbe"]
            #[inline(always)]
            pub fn adc10ie(&mut self) -> _ADC10IEW {
                _ADC10IEW { w: self }
            }
            #[doc = "Bit 4 - ADC10 On/Enable"]
            #[inline(always)]
            pub fn adc10on(&mut self) -> _ADC10ONW {
                _ADC10ONW { w: self }
            }
            #[doc = "Bit 5 - ADC10 Reference on"]
            #[inline(always)]
            pub fn refon(&mut self) -> _REFONW {
                _REFONW { w: self }
            }
            #[doc = "Bit 6 - ADC10 Ref 0:1.5V / 1:2.5V"]
            #[inline(always)]
            pub fn ref2_5v(&mut self) -> _REF2_5VW {
                _REF2_5VW { w: self }
            }
            #[doc = "Bit 7 - ADC10 Multiple SampleConversion"]
            #[inline(always)]
            pub fn msc(&mut self) -> _MSCW {
                _MSCW { w: self }
            }
            #[doc = "Bit 8 - ADC10 Reference Burst Mode"]
            #[inline(always)]
            pub fn refburst(&mut self) -> _REFBURSTW {
                _REFBURSTW { w: self }
            }
            #[doc = "Bit 9 - ADC10 Enalbe output of Ref."]
            #[inline(always)]
            pub fn refout(&mut self) -> _REFOUTW {
                _REFOUTW { w: self }
            }
            #[doc = "Bit 10 - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
            #[inline(always)]
            pub fn adc10sr(&mut self) -> _ADC10SRW {
                _ADC10SRW { w: self }
            }
            #[doc = "Bits 11:12 - ADC10 Sample Hold Select Bit: 0"]
            #[inline(always)]
            pub fn adc10sht(&mut self) -> _ADC10SHTW {
                _ADC10SHTW { w: self }
            }
            #[doc = "Bits 13:15 - ADC10 Reference Select Bit: 0"]
            #[inline(always)]
            pub fn sref(&mut self) -> _SREFW {
                _SREFW { w: self }
            }
        }
    }
    #[doc = "ADC10 Control 1"]
    pub struct ADC10CTL1 {
        register: VolatileCell<u16>,
    }
    #[doc = "ADC10 Control 1"]
    pub mod adc10ctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::ADC10CTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ADC10BUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10BUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10BUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10BUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10BUSYR {
                match value {
                    i => ADC10BUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `CONSEQ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CONSEQR {
            #[doc = "Single channel single conversion"]
            CONSEQ_0,
            #[doc = "Sequence of channels"]
            CONSEQ_1,
            #[doc = "Repeat single channel"]
            CONSEQ_2,
            #[doc = "Repeat sequence of channels"]
            CONSEQ_3,
        }
        impl CONSEQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CONSEQR::CONSEQ_0 => 0,
                    CONSEQR::CONSEQ_1 => 1,
                    CONSEQR::CONSEQ_2 => 2,
                    CONSEQR::CONSEQ_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CONSEQR {
                match value {
                    0 => CONSEQR::CONSEQ_0,
                    1 => CONSEQR::CONSEQ_1,
                    2 => CONSEQR::CONSEQ_2,
                    3 => CONSEQR::CONSEQ_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSEQ_0`"]
            #[inline(always)]
            pub fn is_conseq_0(&self) -> bool {
                *self == CONSEQR::CONSEQ_0
            }
            #[doc = "Checks if the value of the field is `CONSEQ_1`"]
            #[inline(always)]
            pub fn is_conseq_1(&self) -> bool {
                *self == CONSEQR::CONSEQ_1
            }
            #[doc = "Checks if the value of the field is `CONSEQ_2`"]
            #[inline(always)]
            pub fn is_conseq_2(&self) -> bool {
                *self == CONSEQR::CONSEQ_2
            }
            #[doc = "Checks if the value of the field is `CONSEQ_3`"]
            #[inline(always)]
            pub fn is_conseq_3(&self) -> bool {
                *self == CONSEQR::CONSEQ_3
            }
        }
        #[doc = "Possible values of the field `ADC10SSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10SSELR {
            #[doc = "ADC10OSC"]
            ADC10SSEL_0,
            #[doc = "ACLK"]
            ADC10SSEL_1,
            #[doc = "MCLK"]
            ADC10SSEL_2,
            #[doc = "SMCLK"]
            ADC10SSEL_3,
        }
        impl ADC10SSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADC10SSELR::ADC10SSEL_0 => 0,
                    ADC10SSELR::ADC10SSEL_1 => 1,
                    ADC10SSELR::ADC10SSEL_2 => 2,
                    ADC10SSELR::ADC10SSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> ADC10SSELR {
                match value {
                    0 => ADC10SSELR::ADC10SSEL_0,
                    1 => ADC10SSELR::ADC10SSEL_1,
                    2 => ADC10SSELR::ADC10SSEL_2,
                    3 => ADC10SSELR::ADC10SSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ADC10SSEL_0`"]
            #[inline(always)]
            pub fn is_adc10ssel_0(&self) -> bool {
                *self == ADC10SSELR::ADC10SSEL_0
            }
            #[doc = "Checks if the value of the field is `ADC10SSEL_1`"]
            #[inline(always)]
            pub fn is_adc10ssel_1(&self) -> bool {
                *self == ADC10SSELR::ADC10SSEL_1
            }
            #[doc = "Checks if the value of the field is `ADC10SSEL_2`"]
            #[inline(always)]
            pub fn is_adc10ssel_2(&self) -> bool {
                *self == ADC10SSELR::ADC10SSEL_2
            }
            #[doc = "Checks if the value of the field is `ADC10SSEL_3`"]
            #[inline(always)]
            pub fn is_adc10ssel_3(&self) -> bool {
                *self == ADC10SSELR::ADC10SSEL_3
            }
        }
        #[doc = "Possible values of the field `ADC10DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10DIVR {
            #[doc = "ADC10 Clock Divider Select 0"]
            ADC10DIV_0,
            #[doc = "ADC10 Clock Divider Select 1"]
            ADC10DIV_1,
            #[doc = "ADC10 Clock Divider Select 2"]
            ADC10DIV_2,
            #[doc = "ADC10 Clock Divider Select 3"]
            ADC10DIV_3,
            #[doc = "ADC10 Clock Divider Select 4"]
            ADC10DIV_4,
            #[doc = "ADC10 Clock Divider Select 5"]
            ADC10DIV_5,
            #[doc = "ADC10 Clock Divider Select 6"]
            ADC10DIV_6,
            #[doc = "ADC10 Clock Divider Select 7"]
            ADC10DIV_7,
        }
        impl ADC10DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADC10DIVR::ADC10DIV_0 => 0,
                    ADC10DIVR::ADC10DIV_1 => 1,
                    ADC10DIVR::ADC10DIV_2 => 2,
                    ADC10DIVR::ADC10DIV_3 => 3,
                    ADC10DIVR::ADC10DIV_4 => 4,
                    ADC10DIVR::ADC10DIV_5 => 5,
                    ADC10DIVR::ADC10DIV_6 => 6,
                    ADC10DIVR::ADC10DIV_7 => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> ADC10DIVR {
                match value {
                    0 => ADC10DIVR::ADC10DIV_0,
                    1 => ADC10DIVR::ADC10DIV_1,
                    2 => ADC10DIVR::ADC10DIV_2,
                    3 => ADC10DIVR::ADC10DIV_3,
                    4 => ADC10DIVR::ADC10DIV_4,
                    5 => ADC10DIVR::ADC10DIV_5,
                    6 => ADC10DIVR::ADC10DIV_6,
                    7 => ADC10DIVR::ADC10DIV_7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_0`"]
            #[inline(always)]
            pub fn is_adc10div_0(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_0
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_1`"]
            #[inline(always)]
            pub fn is_adc10div_1(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_1
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_2`"]
            #[inline(always)]
            pub fn is_adc10div_2(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_2
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_3`"]
            #[inline(always)]
            pub fn is_adc10div_3(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_3
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_4`"]
            #[inline(always)]
            pub fn is_adc10div_4(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_4
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_5`"]
            #[inline(always)]
            pub fn is_adc10div_5(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_5
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_6`"]
            #[inline(always)]
            pub fn is_adc10div_6(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_6
            }
            #[doc = "Checks if the value of the field is `ADC10DIV_7`"]
            #[inline(always)]
            pub fn is_adc10div_7(&self) -> bool {
                *self == ADC10DIVR::ADC10DIV_7
            }
        }
        #[doc = "Possible values of the field `ISSH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ISSHR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ISSHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ISSHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ISSHR {
                match value {
                    i => ISSHR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ADC10DF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC10DFR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ADC10DFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC10DFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADC10DFR {
                match value {
                    i => ADC10DFR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `SHS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SHSR {
            #[doc = "ADC10SC"]
            SHS_0,
            #[doc = "TA3 OUT1"]
            SHS_1,
            #[doc = "TA3 OUT0"]
            SHS_2,
            #[doc = "TA3 OUT2"]
            SHS_3,
        }
        impl SHSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SHSR::SHS_0 => 0,
                    SHSR::SHS_1 => 1,
                    SHSR::SHS_2 => 2,
                    SHSR::SHS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SHSR {
                match value {
                    0 => SHSR::SHS_0,
                    1 => SHSR::SHS_1,
                    2 => SHSR::SHS_2,
                    3 => SHSR::SHS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SHS_0`"]
            #[inline(always)]
            pub fn is_shs_0(&self) -> bool {
                *self == SHSR::SHS_0
            }
            #[doc = "Checks if the value of the field is `SHS_1`"]
            #[inline(always)]
            pub fn is_shs_1(&self) -> bool {
                *self == SHSR::SHS_1
            }
            #[doc = "Checks if the value of the field is `SHS_2`"]
            #[inline(always)]
            pub fn is_shs_2(&self) -> bool {
                *self == SHSR::SHS_2
            }
            #[doc = "Checks if the value of the field is `SHS_3`"]
            #[inline(always)]
            pub fn is_shs_3(&self) -> bool {
                *self == SHSR::SHS_3
            }
        }
        #[doc = "Possible values of the field `INCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INCHR {
            #[doc = "Selects Channel 0"]
            INCH_0,
            #[doc = "Selects Channel 1"]
            INCH_1,
            #[doc = "Selects Channel 2"]
            INCH_2,
            #[doc = "Selects Channel 3"]
            INCH_3,
            #[doc = "Selects Channel 4"]
            INCH_4,
            #[doc = "Selects Channel 5"]
            INCH_5,
            #[doc = "Selects Channel 6"]
            INCH_6,
            #[doc = "Selects Channel 7"]
            INCH_7,
            #[doc = "Selects Channel 8"]
            INCH_8,
            #[doc = "Selects Channel 9"]
            INCH_9,
            #[doc = "Selects Channel 10"]
            INCH_10,
            #[doc = "Selects Channel 11"]
            INCH_11,
            #[doc = "Selects Channel 12"]
            INCH_12,
            #[doc = "Selects Channel 13"]
            INCH_13,
            #[doc = "Selects Channel 14"]
            INCH_14,
            #[doc = "Selects Channel 15"]
            INCH_15,
        }
        impl INCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    INCHR::INCH_0 => 0,
                    INCHR::INCH_1 => 1,
                    INCHR::INCH_2 => 2,
                    INCHR::INCH_3 => 3,
                    INCHR::INCH_4 => 4,
                    INCHR::INCH_5 => 5,
                    INCHR::INCH_6 => 6,
                    INCHR::INCH_7 => 7,
                    INCHR::INCH_8 => 8,
                    INCHR::INCH_9 => 9,
                    INCHR::INCH_10 => 10,
                    INCHR::INCH_11 => 11,
                    INCHR::INCH_12 => 12,
                    INCHR::INCH_13 => 13,
                    INCHR::INCH_14 => 14,
                    INCHR::INCH_15 => 15,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> INCHR {
                match value {
                    0 => INCHR::INCH_0,
                    1 => INCHR::INCH_1,
                    2 => INCHR::INCH_2,
                    3 => INCHR::INCH_3,
                    4 => INCHR::INCH_4,
                    5 => INCHR::INCH_5,
                    6 => INCHR::INCH_6,
                    7 => INCHR::INCH_7,
                    8 => INCHR::INCH_8,
                    9 => INCHR::INCH_9,
                    10 => INCHR::INCH_10,
                    11 => INCHR::INCH_11,
                    12 => INCHR::INCH_12,
                    13 => INCHR::INCH_13,
                    14 => INCHR::INCH_14,
                    15 => INCHR::INCH_15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INCH_0`"]
            #[inline(always)]
            pub fn is_inch_0(&self) -> bool {
                *self == INCHR::INCH_0
            }
            #[doc = "Checks if the value of the field is `INCH_1`"]
            #[inline(always)]
            pub fn is_inch_1(&self) -> bool {
                *self == INCHR::INCH_1
            }
            #[doc = "Checks if the value of the field is `INCH_2`"]
            #[inline(always)]
            pub fn is_inch_2(&self) -> bool {
                *self == INCHR::INCH_2
            }
            #[doc = "Checks if the value of the field is `INCH_3`"]
            #[inline(always)]
            pub fn is_inch_3(&self) -> bool {
                *self == INCHR::INCH_3
            }
            #[doc = "Checks if the value of the field is `INCH_4`"]
            #[inline(always)]
            pub fn is_inch_4(&self) -> bool {
                *self == INCHR::INCH_4
            }
            #[doc = "Checks if the value of the field is `INCH_5`"]
            #[inline(always)]
            pub fn is_inch_5(&self) -> bool {
                *self == INCHR::INCH_5
            }
            #[doc = "Checks if the value of the field is `INCH_6`"]
            #[inline(always)]
            pub fn is_inch_6(&self) -> bool {
                *self == INCHR::INCH_6
            }
            #[doc = "Checks if the value of the field is `INCH_7`"]
            #[inline(always)]
            pub fn is_inch_7(&self) -> bool {
                *self == INCHR::INCH_7
            }
            #[doc = "Checks if the value of the field is `INCH_8`"]
            #[inline(always)]
            pub fn is_inch_8(&self) -> bool {
                *self == INCHR::INCH_8
            }
            #[doc = "Checks if the value of the field is `INCH_9`"]
            #[inline(always)]
            pub fn is_inch_9(&self) -> bool {
                *self == INCHR::INCH_9
            }
            #[doc = "Checks if the value of the field is `INCH_10`"]
            #[inline(always)]
            pub fn is_inch_10(&self) -> bool {
                *self == INCHR::INCH_10
            }
            #[doc = "Checks if the value of the field is `INCH_11`"]
            #[inline(always)]
            pub fn is_inch_11(&self) -> bool {
                *self == INCHR::INCH_11
            }
            #[doc = "Checks if the value of the field is `INCH_12`"]
            #[inline(always)]
            pub fn is_inch_12(&self) -> bool {
                *self == INCHR::INCH_12
            }
            #[doc = "Checks if the value of the field is `INCH_13`"]
            #[inline(always)]
            pub fn is_inch_13(&self) -> bool {
                *self == INCHR::INCH_13
            }
            #[doc = "Checks if the value of the field is `INCH_14`"]
            #[inline(always)]
            pub fn is_inch_14(&self) -> bool {
                *self == INCHR::INCH_14
            }
            #[doc = "Checks if the value of the field is `INCH_15`"]
            #[inline(always)]
            pub fn is_inch_15(&self) -> bool {
                *self == INCHR::INCH_15
            }
        }
        #[doc = "Values that can be written to the field `ADC10BUSY`"]
        pub enum ADC10BUSYW { }
        impl ADC10BUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10BUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10BUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10BUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CONSEQ`"]
        pub enum CONSEQW {
            #[doc = "Single channel single conversion"]
            CONSEQ_0,
            #[doc = "Sequence of channels"]
            CONSEQ_1,
            #[doc = "Repeat single channel"]
            CONSEQ_2,
            #[doc = "Repeat sequence of channels"]
            CONSEQ_3,
        }
        impl CONSEQW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CONSEQW::CONSEQ_0 => 0,
                    CONSEQW::CONSEQ_1 => 1,
                    CONSEQW::CONSEQ_2 => 2,
                    CONSEQW::CONSEQ_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CONSEQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CONSEQW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CONSEQW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Single channel single conversion"]
            #[inline(always)]
            pub fn conseq_0(self) -> &'a mut W {
                self.variant(CONSEQW::CONSEQ_0)
            }
            #[doc = "Sequence of channels"]
            #[inline(always)]
            pub fn conseq_1(self) -> &'a mut W {
                self.variant(CONSEQW::CONSEQ_1)
            }
            #[doc = "Repeat single channel"]
            #[inline(always)]
            pub fn conseq_2(self) -> &'a mut W {
                self.variant(CONSEQW::CONSEQ_2)
            }
            #[doc = "Repeat sequence of channels"]
            #[inline(always)]
            pub fn conseq_3(self) -> &'a mut W {
                self.variant(CONSEQW::CONSEQ_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10SSEL`"]
        pub enum ADC10SSELW {
            #[doc = "ADC10OSC"]
            ADC10SSEL_0,
            #[doc = "ACLK"]
            ADC10SSEL_1,
            #[doc = "MCLK"]
            ADC10SSEL_2,
            #[doc = "SMCLK"]
            ADC10SSEL_3,
        }
        impl ADC10SSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADC10SSELW::ADC10SSEL_0 => 0,
                    ADC10SSELW::ADC10SSEL_1 => 1,
                    ADC10SSELW::ADC10SSEL_2 => 2,
                    ADC10SSELW::ADC10SSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10SSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10SSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10SSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "ADC10OSC"]
            #[inline(always)]
            pub fn adc10ssel_0(self) -> &'a mut W {
                self.variant(ADC10SSELW::ADC10SSEL_0)
            }
            #[doc = "ACLK"]
            #[inline(always)]
            pub fn adc10ssel_1(self) -> &'a mut W {
                self.variant(ADC10SSELW::ADC10SSEL_1)
            }
            #[doc = "MCLK"]
            #[inline(always)]
            pub fn adc10ssel_2(self) -> &'a mut W {
                self.variant(ADC10SSELW::ADC10SSEL_2)
            }
            #[doc = "SMCLK"]
            #[inline(always)]
            pub fn adc10ssel_3(self) -> &'a mut W {
                self.variant(ADC10SSELW::ADC10SSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10DIV`"]
        pub enum ADC10DIVW {
            #[doc = "ADC10 Clock Divider Select 0"]
            ADC10DIV_0,
            #[doc = "ADC10 Clock Divider Select 1"]
            ADC10DIV_1,
            #[doc = "ADC10 Clock Divider Select 2"]
            ADC10DIV_2,
            #[doc = "ADC10 Clock Divider Select 3"]
            ADC10DIV_3,
            #[doc = "ADC10 Clock Divider Select 4"]
            ADC10DIV_4,
            #[doc = "ADC10 Clock Divider Select 5"]
            ADC10DIV_5,
            #[doc = "ADC10 Clock Divider Select 6"]
            ADC10DIV_6,
            #[doc = "ADC10 Clock Divider Select 7"]
            ADC10DIV_7,
        }
        impl ADC10DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADC10DIVW::ADC10DIV_0 => 0,
                    ADC10DIVW::ADC10DIV_1 => 1,
                    ADC10DIVW::ADC10DIV_2 => 2,
                    ADC10DIVW::ADC10DIV_3 => 3,
                    ADC10DIVW::ADC10DIV_4 => 4,
                    ADC10DIVW::ADC10DIV_5 => 5,
                    ADC10DIVW::ADC10DIV_6 => 6,
                    ADC10DIVW::ADC10DIV_7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10DIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "ADC10 Clock Divider Select 0"]
            #[inline(always)]
            pub fn adc10div_0(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_0)
            }
            #[doc = "ADC10 Clock Divider Select 1"]
            #[inline(always)]
            pub fn adc10div_1(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_1)
            }
            #[doc = "ADC10 Clock Divider Select 2"]
            #[inline(always)]
            pub fn adc10div_2(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_2)
            }
            #[doc = "ADC10 Clock Divider Select 3"]
            #[inline(always)]
            pub fn adc10div_3(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_3)
            }
            #[doc = "ADC10 Clock Divider Select 4"]
            #[inline(always)]
            pub fn adc10div_4(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_4)
            }
            #[doc = "ADC10 Clock Divider Select 5"]
            #[inline(always)]
            pub fn adc10div_5(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_5)
            }
            #[doc = "ADC10 Clock Divider Select 6"]
            #[inline(always)]
            pub fn adc10div_6(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_6)
            }
            #[doc = "ADC10 Clock Divider Select 7"]
            #[inline(always)]
            pub fn adc10div_7(self) -> &'a mut W {
                self.variant(ADC10DIVW::ADC10DIV_7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ISSH`"]
        pub enum ISSHW { }
        impl ISSHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISSHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ISSHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC10DF`"]
        pub enum ADC10DFW { }
        impl ADC10DFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC10DFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC10DFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC10DFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SHS`"]
        pub enum SHSW {
            #[doc = "ADC10SC"]
            SHS_0,
            #[doc = "TA3 OUT1"]
            SHS_1,
            #[doc = "TA3 OUT0"]
            SHS_2,
            #[doc = "TA3 OUT2"]
            SHS_3,
        }
        impl SHSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SHSW::SHS_0 => 0,
                    SHSW::SHS_1 => 1,
                    SHSW::SHS_2 => 2,
                    SHSW::SHS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SHSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SHSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SHSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "ADC10SC"]
            #[inline(always)]
            pub fn shs_0(self) -> &'a mut W {
                self.variant(SHSW::SHS_0)
            }
            #[doc = "TA3 OUT1"]
            #[inline(always)]
            pub fn shs_1(self) -> &'a mut W {
                self.variant(SHSW::SHS_1)
            }
            #[doc = "TA3 OUT0"]
            #[inline(always)]
            pub fn shs_2(self) -> &'a mut W {
                self.variant(SHSW::SHS_2)
            }
            #[doc = "TA3 OUT2"]
            #[inline(always)]
            pub fn shs_3(self) -> &'a mut W {
                self.variant(SHSW::SHS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INCH`"]
        pub enum INCHW {
            #[doc = "Selects Channel 0"]
            INCH_0,
            #[doc = "Selects Channel 1"]
            INCH_1,
            #[doc = "Selects Channel 2"]
            INCH_2,
            #[doc = "Selects Channel 3"]
            INCH_3,
            #[doc = "Selects Channel 4"]
            INCH_4,
            #[doc = "Selects Channel 5"]
            INCH_5,
            #[doc = "Selects Channel 6"]
            INCH_6,
            #[doc = "Selects Channel 7"]
            INCH_7,
            #[doc = "Selects Channel 8"]
            INCH_8,
            #[doc = "Selects Channel 9"]
            INCH_9,
            #[doc = "Selects Channel 10"]
            INCH_10,
            #[doc = "Selects Channel 11"]
            INCH_11,
            #[doc = "Selects Channel 12"]
            INCH_12,
            #[doc = "Selects Channel 13"]
            INCH_13,
            #[doc = "Selects Channel 14"]
            INCH_14,
            #[doc = "Selects Channel 15"]
            INCH_15,
        }
        impl INCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INCHW::INCH_0 => 0,
                    INCHW::INCH_1 => 1,
                    INCHW::INCH_2 => 2,
                    INCHW::INCH_3 => 3,
                    INCHW::INCH_4 => 4,
                    INCHW::INCH_5 => 5,
                    INCHW::INCH_6 => 6,
                    INCHW::INCH_7 => 7,
                    INCHW::INCH_8 => 8,
                    INCHW::INCH_9 => 9,
                    INCHW::INCH_10 => 10,
                    INCHW::INCH_11 => 11,
                    INCHW::INCH_12 => 12,
                    INCHW::INCH_13 => 13,
                    INCHW::INCH_14 => 14,
                    INCHW::INCH_15 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INCHW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Selects Channel 0"]
            #[inline(always)]
            pub fn inch_0(self) -> &'a mut W {
                self.variant(INCHW::INCH_0)
            }
            #[doc = "Selects Channel 1"]
            #[inline(always)]
            pub fn inch_1(self) -> &'a mut W {
                self.variant(INCHW::INCH_1)
            }
            #[doc = "Selects Channel 2"]
            #[inline(always)]
            pub fn inch_2(self) -> &'a mut W {
                self.variant(INCHW::INCH_2)
            }
            #[doc = "Selects Channel 3"]
            #[inline(always)]
            pub fn inch_3(self) -> &'a mut W {
                self.variant(INCHW::INCH_3)
            }
            #[doc = "Selects Channel 4"]
            #[inline(always)]
            pub fn inch_4(self) -> &'a mut W {
                self.variant(INCHW::INCH_4)
            }
            #[doc = "Selects Channel 5"]
            #[inline(always)]
            pub fn inch_5(self) -> &'a mut W {
                self.variant(INCHW::INCH_5)
            }
            #[doc = "Selects Channel 6"]
            #[inline(always)]
            pub fn inch_6(self) -> &'a mut W {
                self.variant(INCHW::INCH_6)
            }
            #[doc = "Selects Channel 7"]
            #[inline(always)]
            pub fn inch_7(self) -> &'a mut W {
                self.variant(INCHW::INCH_7)
            }
            #[doc = "Selects Channel 8"]
            #[inline(always)]
            pub fn inch_8(self) -> &'a mut W {
                self.variant(INCHW::INCH_8)
            }
            #[doc = "Selects Channel 9"]
            #[inline(always)]
            pub fn inch_9(self) -> &'a mut W {
                self.variant(INCHW::INCH_9)
            }
            #[doc = "Selects Channel 10"]
            #[inline(always)]
            pub fn inch_10(self) -> &'a mut W {
                self.variant(INCHW::INCH_10)
            }
            #[doc = "Selects Channel 11"]
            #[inline(always)]
            pub fn inch_11(self) -> &'a mut W {
                self.variant(INCHW::INCH_11)
            }
            #[doc = "Selects Channel 12"]
            #[inline(always)]
            pub fn inch_12(self) -> &'a mut W {
                self.variant(INCHW::INCH_12)
            }
            #[doc = "Selects Channel 13"]
            #[inline(always)]
            pub fn inch_13(self) -> &'a mut W {
                self.variant(INCHW::INCH_13)
            }
            #[doc = "Selects Channel 14"]
            #[inline(always)]
            pub fn inch_14(self) -> &'a mut W {
                self.variant(INCHW::INCH_14)
            }
            #[doc = "Selects Channel 15"]
            #[inline(always)]
            pub fn inch_15(self) -> &'a mut W {
                self.variant(INCHW::INCH_15)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - ADC10 BUSY"]
            #[inline(always)]
            pub fn adc10busy(&self) -> ADC10BUSYR {
                ADC10BUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 1:2 - ADC10 Conversion Sequence Select 0"]
            #[inline(always)]
            pub fn conseq(&self) -> CONSEQR {
                CONSEQR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 3:4 - ADC10 Clock Source Select Bit: 0"]
            #[inline(always)]
            pub fn adc10ssel(&self) -> ADC10SSELR {
                ADC10SSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 5:7 - ADC10 Clock Divider Select Bit: 0"]
            #[inline(always)]
            pub fn adc10div(&self) -> ADC10DIVR {
                ADC10DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 8 - ADC10 Invert Sample Hold Signal"]
            #[inline(always)]
            pub fn issh(&self) -> ISSHR {
                ISSHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bit 9 - ADC10 Data Format 0:binary 1:2's complement"]
            #[inline(always)]
            pub fn adc10df(&self) -> ADC10DFR {
                ADC10DFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                })
            }
            #[doc = "Bits 10:11 - ADC10 Sample/Hold Source Bit: 0"]
            #[inline(always)]
            pub fn shs(&self) -> SHSR {
                SHSR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 12:15 - ADC10 Input Channel Select Bit: 0"]
            #[inline(always)]
            pub fn inch(&self) -> INCHR {
                INCHR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ADC10 BUSY"]
            #[inline(always)]
            pub fn adc10busy(&mut self) -> _ADC10BUSYW {
                _ADC10BUSYW { w: self }
            }
            #[doc = "Bits 1:2 - ADC10 Conversion Sequence Select 0"]
            #[inline(always)]
            pub fn conseq(&mut self) -> _CONSEQW {
                _CONSEQW { w: self }
            }
            #[doc = "Bits 3:4 - ADC10 Clock Source Select Bit: 0"]
            #[inline(always)]
            pub fn adc10ssel(&mut self) -> _ADC10SSELW {
                _ADC10SSELW { w: self }
            }
            #[doc = "Bits 5:7 - ADC10 Clock Divider Select Bit: 0"]
            #[inline(always)]
            pub fn adc10div(&mut self) -> _ADC10DIVW {
                _ADC10DIVW { w: self }
            }
            #[doc = "Bit 8 - ADC10 Invert Sample Hold Signal"]
            #[inline(always)]
            pub fn issh(&mut self) -> _ISSHW {
                _ISSHW { w: self }
            }
            #[doc = "Bit 9 - ADC10 Data Format 0:binary 1:2's complement"]
            #[inline(always)]
            pub fn adc10df(&mut self) -> _ADC10DFW {
                _ADC10DFW { w: self }
            }
            #[doc = "Bits 10:11 - ADC10 Sample/Hold Source Bit: 0"]
            #[inline(always)]
            pub fn shs(&mut self) -> _SHSW {
                _SHSW { w: self }
            }
            #[doc = "Bits 12:15 - ADC10 Input Channel Select Bit: 0"]
            #[inline(always)]
            pub fn inch(&mut self) -> _INCHW {
                _INCHW { w: self }
            }
        }
    }
    #[doc = "ADC10 Memory"]
    pub struct ADC10MEM {
        register: VolatileCell<u16>,
    }
    #[doc = "ADC10 Memory"]
    pub mod adc10mem {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::ADC10MEM {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ADC10 Data Transfer Start Address"]
    pub struct ADC10SA {
        register: VolatileCell<u16>,
    }
    #[doc = "ADC10 Data Transfer Start Address"]
    pub mod adc10sa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::ADC10SA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "ADC10"]
pub struct ADC10 {
    register_block: adc10::RegisterBlock,
}
impl Deref for ADC10 {
    type Target = adc10::RegisterBlock;
    fn deref(&self) -> &adc10::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USCI_B0 SPI Mode"]
pub const USCI_B0_SPI_MODE: Peripheral<USCI_B0_SPI_MODE> =
    unsafe { Peripheral::new(104) };
#[doc = "USCI_B0 SPI Mode"]
pub mod usci_b0_spi_mode {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USCI B0 Control Register 0"]
        pub ucb0ctl0: UCB0CTL0,
        #[doc = "0x01 - USCI B0 Control Register 1"]
        pub ucb0ctl1: UCB0CTL1,
        #[doc = "0x02 - USCI B0 Baud Rate 0"]
        pub ucb0br0: UCB0BR0,
        #[doc = "0x03 - USCI B0 Baud Rate 1"]
        pub ucb0br1: UCB0BR1,
        _reserved0: [u8; 1usize],
        #[doc = "0x05 - USCI B0 Status Register"]
        pub ucb0stat: UCB0STAT,
        #[doc = "0x06 - USCI B0 Receive Buffer"]
        pub ucb0rxbuf: UCB0RXBUF,
        #[doc = "0x07 - USCI B0 Transmit Buffer"]
        pub ucb0txbuf: UCB0TXBUF,
    }
    #[doc = "USCI B0 Control Register 0"]
    pub struct UCB0CTL0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Control Register 0"]
    pub mod ucb0ctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0CTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSYNCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSYNCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSYNCR {
                match value {
                    i => UCSYNCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMODER {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCMODER::UCMODE_0 => 0,
                    UCMODER::UCMODE_1 => 1,
                    UCMODER::UCMODE_2 => 2,
                    UCMODER::UCMODE_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCMODER {
                match value {
                    0 => UCMODER::UCMODE_0,
                    1 => UCMODER::UCMODE_1,
                    2 => UCMODER::UCMODE_2,
                    3 => UCMODER::UCMODE_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCMODE_0`"]
            #[inline(always)]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UCMODER::UCMODE_0
            }
            #[doc = "Checks if the value of the field is `UCMODE_1`"]
            #[inline(always)]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UCMODER::UCMODE_1
            }
            #[doc = "Checks if the value of the field is `UCMODE_2`"]
            #[inline(always)]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UCMODER::UCMODE_2
            }
            #[doc = "Checks if the value of the field is `UCMODE_3`"]
            #[inline(always)]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UCMODER::UCMODE_3
            }
        }
        #[doc = "Possible values of the field `UCMST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSTR {
                match value {
                    i => UCMSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UC7BIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UC7BITR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UC7BITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UC7BITR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UC7BITR {
                match value {
                    i => UC7BITR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMSB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSBR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSBR {
                match value {
                    i => UCMSBR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCCKPL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCCKPLR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCCKPLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCCKPLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCCKPLR {
                match value {
                    i => UCCKPLR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCCKPH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCCKPHR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCCKPHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCCKPHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCCKPHR {
                match value {
                    i => UCCKPHR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCSYNC`"]
        pub enum UCSYNCW { }
        impl UCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSYNCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMODE`"]
        pub enum UCMODEW {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCMODEW::UCMODE_0 => 0,
                    UCMODEW::UCMODE_1 => 1,
                    UCMODEW::UCMODE_2 => 2,
                    UCMODEW::UCMODE_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Sync. Mode: USCI Mode: 0"]
            #[inline(always)]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_0)
            }
            #[doc = "Sync. Mode: USCI Mode: 1"]
            #[inline(always)]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_1)
            }
            #[doc = "Sync. Mode: USCI Mode: 2"]
            #[inline(always)]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_2)
            }
            #[doc = "Sync. Mode: USCI Mode: 3"]
            #[inline(always)]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMST`"]
        pub enum UCMSTW { }
        impl UCMSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UC7BIT`"]
        pub enum UC7BITW { }
        impl UC7BITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UC7BITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UC7BITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UC7BITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMSB`"]
        pub enum UCMSBW { }
        impl UCMSBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCCKPL`"]
        pub enum UCCKPLW { }
        impl UCCKPLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCCKPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCCKPLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCCKPLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCCKPH`"]
        pub enum UCCKPHW { }
        impl UCCKPHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCCKPHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCCKPHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCCKPHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&self) -> UCSYNCR {
                UCSYNCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&self) -> UCMODER {
                UCMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&self) -> UCMSTR {
                UCMSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&self) -> UC7BITR {
                UC7BITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&self) -> UCMSBR {
                UCMSBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - Sync. Mode: Clock Polarity"]
            #[inline(always)]
            pub fn ucckpl(&self) -> UCCKPLR {
                UCCKPLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn ucckph(&self) -> UCCKPHR {
                UCCKPHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&mut self) -> _UCSYNCW {
                _UCSYNCW { w: self }
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&mut self) -> _UCMODEW {
                _UCMODEW { w: self }
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&mut self) -> _UCMSTW {
                _UCMSTW { w: self }
            }
            #[doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&mut self) -> _UC7BITW {
                _UC7BITW { w: self }
            }
            #[doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&mut self) -> _UCMSBW {
                _UCMSBW { w: self }
            }
            #[doc = "Bit 6 - Sync. Mode: Clock Polarity"]
            #[inline(always)]
            pub fn ucckpl(&mut self) -> _UCCKPLW {
                _UCCKPLW { w: self }
            }
            #[doc = "Bit 7 - Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn ucckph(&mut self) -> _UCCKPHW {
                _UCCKPHW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Control Register 1"]
    pub struct UCB0CTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Control Register 1"]
    pub mod ucb0ctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0CTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSWRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSWRSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSWRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSWRSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSWRSTR {
                match value {
                    i => UCSWRSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSSELR {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCSSELR::UCSSEL_0 => 0,
                    UCSSELR::UCSSEL_1 => 1,
                    UCSSELR::UCSSEL_2 => 2,
                    UCSSELR::UCSSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCSSELR {
                match value {
                    0 => UCSSELR::UCSSEL_0,
                    1 => UCSSELR::UCSSEL_1,
                    2 => UCSSELR::UCSSEL_2,
                    3 => UCSSELR::UCSSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCSSEL_0`"]
            #[inline(always)]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UCSSELR::UCSSEL_0
            }
            #[doc = "Checks if the value of the field is `UCSSEL_1`"]
            #[inline(always)]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UCSSELR::UCSSEL_1
            }
            #[doc = "Checks if the value of the field is `UCSSEL_2`"]
            #[inline(always)]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UCSSELR::UCSSEL_2
            }
            #[doc = "Checks if the value of the field is `UCSSEL_3`"]
            #[inline(always)]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UCSSELR::UCSSEL_3
            }
        }
        #[doc = "Values that can be written to the field `UCSWRST`"]
        pub enum UCSWRSTW { }
        impl UCSWRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSWRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSWRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSSEL`"]
        pub enum UCSSELW {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCSSELW::UCSSEL_0 => 0,
                    UCSSELW::UCSSEL_1 => 1,
                    UCSSELW::UCSSEL_2 => 2,
                    UCSSELW::UCSSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI 0 Clock Source: 0"]
            #[inline(always)]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_0)
            }
            #[doc = "USCI 0 Clock Source: 1"]
            #[inline(always)]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_1)
            }
            #[doc = "USCI 0 Clock Source: 2"]
            #[inline(always)]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_2)
            }
            #[doc = "USCI 0 Clock Source: 3"]
            #[inline(always)]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&self) -> UCSWRSTR {
                UCSWRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&self) -> UCSSELR {
                UCSSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&mut self) -> _UCSWRSTW {
                _UCSWRSTW { w: self }
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&mut self) -> _UCSSELW {
                _UCSSELW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Baud Rate 0"]
    pub struct UCB0BR0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Baud Rate 0"]
    pub mod ucb0br0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0BR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 Baud Rate 1"]
    pub struct UCB0BR1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Baud Rate 1"]
    pub mod ucb0br1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0BR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 Status Register"]
    pub struct UCB0STAT {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Status Register"]
    pub mod ucb0stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCBUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBUSYR {
                match value {
                    i => UCBUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOER {
                match value {
                    i => UCOER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCFE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCFER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCFER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCFER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCFER {
                match value {
                    i => UCFER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCLISTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCLISTENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCLISTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCLISTENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCLISTENR {
                match value {
                    i => UCLISTENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCBUSY`"]
        pub enum UCBUSYW { }
        impl UCBUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOE`"]
        pub enum UCOEW { }
        impl UCOEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCFE`"]
        pub enum UCFEW { }
        impl UCFEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCFEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCFEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCFEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCLISTEN`"]
        pub enum UCLISTENW { }
        impl UCLISTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCLISTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCLISTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCLISTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&self) -> UCBUSYR {
                UCBUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&self) -> UCOER {
                UCOER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&self) -> UCFER {
                UCFER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&self) -> UCLISTENR {
                UCLISTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&mut self) -> _UCBUSYW {
                _UCBUSYW { w: self }
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&mut self) -> _UCOEW {
                _UCOEW { w: self }
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&mut self) -> _UCFEW {
                _UCFEW { w: self }
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&mut self) -> _UCLISTENW {
                _UCLISTENW { w: self }
            }
        }
    }
    #[doc = "USCI B0 Receive Buffer"]
    pub struct UCB0RXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Receive Buffer"]
    pub mod ucb0rxbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0RXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI B0 Transmit Buffer"]
    pub struct UCB0TXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI B0 Transmit Buffer"]
    pub mod ucb0txbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCB0TXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "USCI_B0 SPI Mode"]
pub struct USCI_B0_SPI_MODE {
    register_block: usci_b0_spi_mode::RegisterBlock,
}
impl Deref for USCI_B0_SPI_MODE {
    type Target = usci_b0_spi_mode::RegisterBlock;
    fn deref(&self) -> &usci_b0_spi_mode::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USCI_A0 SPI Mode"]
pub const USCI_A0_SPI_MODE: Peripheral<USCI_A0_SPI_MODE> =
    unsafe { Peripheral::new(96) };
#[doc = "USCI_A0 SPI Mode"]
pub mod usci_a0_spi_mode {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USCI A0 Control Register 0"]
        pub uca0ctl0: UCA0CTL0,
        #[doc = "0x01 - USCI A0 Control Register 1"]
        pub uca0ctl1: UCA0CTL1,
        #[doc = "0x02 - USCI A0 Baud Rate 0"]
        pub uca0br0: UCA0BR0,
        #[doc = "0x03 - USCI A0 Baud Rate 1"]
        pub uca0br1: UCA0BR1,
        #[doc = "0x04 - USCI A0 Modulation Control"]
        pub uca0mctl: UCA0MCTL,
        #[doc = "0x05 - USCI A0 Status Register"]
        pub uca0stat: UCA0STAT,
        #[doc = "0x06 - USCI A0 Receive Buffer"]
        pub uca0rxbuf: UCA0RXBUF,
        #[doc = "0x07 - USCI A0 Transmit Buffer"]
        pub uca0txbuf: UCA0TXBUF,
    }
    #[doc = "USCI A0 Control Register 0"]
    pub struct UCA0CTL0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Control Register 0"]
    pub mod uca0ctl0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0CTL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSYNCR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSYNCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSYNCR {
                match value {
                    i => UCSYNCR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMODER {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCMODER::UCMODE_0 => 0,
                    UCMODER::UCMODE_1 => 1,
                    UCMODER::UCMODE_2 => 2,
                    UCMODER::UCMODE_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCMODER {
                match value {
                    0 => UCMODER::UCMODE_0,
                    1 => UCMODER::UCMODE_1,
                    2 => UCMODER::UCMODE_2,
                    3 => UCMODER::UCMODE_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCMODE_0`"]
            #[inline(always)]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UCMODER::UCMODE_0
            }
            #[doc = "Checks if the value of the field is `UCMODE_1`"]
            #[inline(always)]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UCMODER::UCMODE_1
            }
            #[doc = "Checks if the value of the field is `UCMODE_2`"]
            #[inline(always)]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UCMODER::UCMODE_2
            }
            #[doc = "Checks if the value of the field is `UCMODE_3`"]
            #[inline(always)]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UCMODER::UCMODE_3
            }
        }
        #[doc = "Possible values of the field `UCMST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSTR {
                match value {
                    i => UCMSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UC7BIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UC7BITR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UC7BITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UC7BITR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UC7BITR {
                match value {
                    i => UC7BITR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCMSB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCMSBR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCMSBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCMSBR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCMSBR {
                match value {
                    i => UCMSBR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCCKPL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCCKPLR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCCKPLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCCKPLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCCKPLR {
                match value {
                    i => UCCKPLR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCCKPH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCCKPHR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCCKPHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCCKPHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCCKPHR {
                match value {
                    i => UCCKPHR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCSYNC`"]
        pub enum UCSYNCW { }
        impl UCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSYNCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMODE`"]
        pub enum UCMODEW {
            #[doc = "Sync. Mode: USCI Mode: 0"]
            UCMODE_0,
            #[doc = "Sync. Mode: USCI Mode: 1"]
            UCMODE_1,
            #[doc = "Sync. Mode: USCI Mode: 2"]
            UCMODE_2,
            #[doc = "Sync. Mode: USCI Mode: 3"]
            UCMODE_3,
        }
        impl UCMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCMODEW::UCMODE_0 => 0,
                    UCMODEW::UCMODE_1 => 1,
                    UCMODEW::UCMODE_2 => 2,
                    UCMODEW::UCMODE_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Sync. Mode: USCI Mode: 0"]
            #[inline(always)]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_0)
            }
            #[doc = "Sync. Mode: USCI Mode: 1"]
            #[inline(always)]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_1)
            }
            #[doc = "Sync. Mode: USCI Mode: 2"]
            #[inline(always)]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_2)
            }
            #[doc = "Sync. Mode: USCI Mode: 3"]
            #[inline(always)]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UCMODEW::UCMODE_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMST`"]
        pub enum UCMSTW { }
        impl UCMSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UC7BIT`"]
        pub enum UC7BITW { }
        impl UC7BITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UC7BITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UC7BITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UC7BITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCMSB`"]
        pub enum UCMSBW { }
        impl UCMSBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCMSBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCMSBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCMSBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCCKPL`"]
        pub enum UCCKPLW { }
        impl UCCKPLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCCKPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCCKPLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCCKPLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCCKPH`"]
        pub enum UCCKPHW { }
        impl UCCKPHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCCKPHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCCKPHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCCKPHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&self) -> UCSYNCR {
                UCSYNCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&self) -> UCMODER {
                UCMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&self) -> UCMSTR {
                UCMSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&self) -> UC7BITR {
                UC7BITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&self) -> UCMSBR {
                UCMSBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - Sync. Mode: Clock Polarity"]
            #[inline(always)]
            pub fn ucckpl(&self) -> UCCKPLR {
                UCCKPLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn ucckph(&self) -> UCCKPHR {
                UCCKPHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode"]
            #[inline(always)]
            pub fn ucsync(&mut self) -> _UCSYNCW {
                _UCSYNCW { w: self }
            }
            #[doc = "Bits 1:2 - Sync. Mode: USCI Mode 1"]
            #[inline(always)]
            pub fn ucmode(&mut self) -> _UCMODEW {
                _UCMODEW { w: self }
            }
            #[doc = "Bit 3 - Sync. Mode: Master Select"]
            #[inline(always)]
            pub fn ucmst(&mut self) -> _UCMSTW {
                _UCMSTW { w: self }
            }
            #[doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits"]
            #[inline(always)]
            pub fn uc7bit(&mut self) -> _UC7BITW {
                _UC7BITW { w: self }
            }
            #[doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB"]
            #[inline(always)]
            pub fn ucmsb(&mut self) -> _UCMSBW {
                _UCMSBW { w: self }
            }
            #[doc = "Bit 6 - Sync. Mode: Clock Polarity"]
            #[inline(always)]
            pub fn ucckpl(&mut self) -> _UCCKPLW {
                _UCCKPLW { w: self }
            }
            #[doc = "Bit 7 - Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn ucckph(&mut self) -> _UCCKPHW {
                _UCCKPHW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Control Register 1"]
    pub struct UCA0CTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Control Register 1"]
    pub mod uca0ctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0CTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCSWRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSWRSTR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCSWRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCSWRSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCSWRSTR {
                match value {
                    i => UCSWRSTR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCSSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCSSELR {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    UCSSELR::UCSSEL_0 => 0,
                    UCSSELR::UCSSEL_1 => 1,
                    UCSSELR::UCSSEL_2 => 2,
                    UCSSELR::UCSSEL_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> UCSSELR {
                match value {
                    0 => UCSSELR::UCSSEL_0,
                    1 => UCSSELR::UCSSEL_1,
                    2 => UCSSELR::UCSSEL_2,
                    3 => UCSSELR::UCSSEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `UCSSEL_0`"]
            #[inline(always)]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UCSSELR::UCSSEL_0
            }
            #[doc = "Checks if the value of the field is `UCSSEL_1`"]
            #[inline(always)]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UCSSELR::UCSSEL_1
            }
            #[doc = "Checks if the value of the field is `UCSSEL_2`"]
            #[inline(always)]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UCSSELR::UCSSEL_2
            }
            #[doc = "Checks if the value of the field is `UCSSEL_3`"]
            #[inline(always)]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UCSSELR::UCSSEL_3
            }
        }
        #[doc = "Values that can be written to the field `UCSWRST`"]
        pub enum UCSWRSTW { }
        impl UCSWRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSWRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSWRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCSSEL`"]
        pub enum UCSSELW {
            #[doc = "USCI 0 Clock Source: 0"]
            UCSSEL_0,
            #[doc = "USCI 0 Clock Source: 1"]
            UCSSEL_1,
            #[doc = "USCI 0 Clock Source: 2"]
            UCSSEL_2,
            #[doc = "USCI 0 Clock Source: 3"]
            UCSSEL_3,
        }
        impl UCSSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UCSSELW::UCSSEL_0 => 0,
                    UCSSELW::UCSSEL_1 => 1,
                    UCSSELW::UCSSEL_2 => 2,
                    UCSSELW::UCSSEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCSSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCSSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCSSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "USCI 0 Clock Source: 0"]
            #[inline(always)]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_0)
            }
            #[doc = "USCI 0 Clock Source: 1"]
            #[inline(always)]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_1)
            }
            #[doc = "USCI 0 Clock Source: 2"]
            #[inline(always)]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_2)
            }
            #[doc = "USCI 0 Clock Source: 3"]
            #[inline(always)]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UCSSELW::UCSSEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&self) -> UCSWRSTR {
                UCSWRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&self) -> UCSSELR {
                UCSSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Software Reset"]
            #[inline(always)]
            pub fn ucswrst(&mut self) -> _UCSWRSTW {
                _UCSWRSTW { w: self }
            }
            #[doc = "Bits 6:7 - USCI 1 Clock Source Select 1"]
            #[inline(always)]
            pub fn ucssel(&mut self) -> _UCSSELW {
                _UCSSELW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Baud Rate 0"]
    pub struct UCA0BR0 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Baud Rate 0"]
    pub mod uca0br0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0BR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Baud Rate 1"]
    pub struct UCA0BR1 {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Baud Rate 1"]
    pub mod uca0br1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0BR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Modulation Control"]
    pub struct UCA0MCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Modulation Control"]
    pub mod uca0mctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0MCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Status Register"]
    pub struct UCA0STAT {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Status Register"]
    pub mod uca0stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCBUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCBUSYR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCBUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCBUSYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCBUSYR {
                match value {
                    i => UCBUSYR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCOE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCOER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCOER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCOER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCOER {
                match value {
                    i => UCOER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCFE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCFER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCFER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCFER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCFER {
                match value {
                    i => UCFER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCLISTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCLISTENR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCLISTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCLISTENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCLISTENR {
                match value {
                    i => UCLISTENR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCBUSY`"]
        pub enum UCBUSYW { }
        impl UCBUSYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCBUSYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCBUSYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCBUSYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCOE`"]
        pub enum UCOEW { }
        impl UCOEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCOEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCOEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCFE`"]
        pub enum UCFEW { }
        impl UCFEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCFEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCFEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCFEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCLISTEN`"]
        pub enum UCLISTENW { }
        impl UCLISTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCLISTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCLISTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCLISTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&self) -> UCBUSYR {
                UCBUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&self) -> UCOER {
                UCOER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&self) -> UCFER {
                UCFER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&self) -> UCLISTENR {
                UCLISTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USCI Busy Flag"]
            #[inline(always)]
            pub fn ucbusy(&mut self) -> _UCBUSYW {
                _UCBUSYW { w: self }
            }
            #[doc = "Bit 5 - USCI Overrun Error Flag"]
            #[inline(always)]
            pub fn ucoe(&mut self) -> _UCOEW {
                _UCOEW { w: self }
            }
            #[doc = "Bit 6 - USCI Frame Error Flag"]
            #[inline(always)]
            pub fn ucfe(&mut self) -> _UCFEW {
                _UCFEW { w: self }
            }
            #[doc = "Bit 7 - USCI Listen mode"]
            #[inline(always)]
            pub fn uclisten(&mut self) -> _UCLISTENW {
                _UCLISTENW { w: self }
            }
        }
    }
    #[doc = "USCI A0 Receive Buffer"]
    pub struct UCA0RXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Receive Buffer"]
    pub mod uca0rxbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0RXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "USCI A0 Transmit Buffer"]
    pub struct UCA0TXBUF {
        register: VolatileCell<u8>,
    }
    #[doc = "USCI A0 Transmit Buffer"]
    pub mod uca0txbuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::UCA0TXBUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "USCI_A0 SPI Mode"]
pub struct USCI_A0_SPI_MODE {
    register_block: usci_a0_spi_mode::RegisterBlock,
}
impl Deref for USCI_A0_SPI_MODE {
    type Target = usci_a0_spi_mode::RegisterBlock;
    fn deref(&self) -> &usci_a0_spi_mode::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Special Function"]
pub const SPECIAL_FUNCTION: Peripheral<SPECIAL_FUNCTION> =
    unsafe { Peripheral::new(0) };
#[doc = "Special Function"]
pub mod special_function {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Enable 1"]
        pub ie1: IE1,
        #[doc = "0x01 - Interrupt Enable 2"]
        pub ie2: IE2,
        #[doc = "0x02 - Interrupt Flag 1"]
        pub ifg1: IFG1,
        #[doc = "0x03 - Interrupt Flag 2"]
        pub ifg2: IFG2,
    }
    #[doc = "Interrupt Enable 1"]
    pub struct IE1 {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable 1"]
    pub mod ie1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::IE1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDTIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTIER {
                match value {
                    i => WDTIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OFIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OFIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OFIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OFIER {
                match value {
                    i => OFIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `NMIIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NMIIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl NMIIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    NMIIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> NMIIER {
                match value {
                    i => NMIIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `ACCVIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACCVIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl ACCVIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACCVIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACCVIER {
                match value {
                    i => ACCVIER::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `WDTIE`"]
        pub enum WDTIEW { }
        impl WDTIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFIE`"]
        pub enum OFIEW { }
        impl OFIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OFIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NMIIE`"]
        pub enum NMIIEW { }
        impl NMIIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NMIIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACCVIE`"]
        pub enum ACCVIEW { }
        impl ACCVIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCVIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCVIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACCVIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog Interrupt Enable"]
            #[inline(always)]
            pub fn wdtie(&self) -> WDTIER {
                WDTIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Enable"]
            #[inline(always)]
            pub fn ofie(&self) -> OFIER {
                OFIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - NMI Interrupt Enable"]
            #[inline(always)]
            pub fn nmiie(&self) -> NMIIER {
                NMIIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - Flash Access Violation Interrupt Enable"]
            #[inline(always)]
            pub fn accvie(&self) -> ACCVIER {
                ACCVIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Watchdog Interrupt Enable"]
            #[inline(always)]
            pub fn wdtie(&mut self) -> _WDTIEW {
                _WDTIEW { w: self }
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Enable"]
            #[inline(always)]
            pub fn ofie(&mut self) -> _OFIEW {
                _OFIEW { w: self }
            }
            #[doc = "Bit 4 - NMI Interrupt Enable"]
            #[inline(always)]
            pub fn nmiie(&mut self) -> _NMIIEW {
                _NMIIEW { w: self }
            }
            #[doc = "Bit 5 - Flash Access Violation Interrupt Enable"]
            #[inline(always)]
            pub fn accvie(&mut self) -> _ACCVIEW {
                _ACCVIEW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable 2"]
    pub struct IE2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable 2"]
    pub mod ie2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::IE2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCA0RXIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCA0RXIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCA0RXIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCA0RXIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCA0RXIER {
                match value {
                    i => UCA0RXIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCA0TXIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCA0TXIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCA0TXIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCA0TXIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCA0TXIER {
                match value {
                    i => UCA0TXIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCB0RXIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCB0RXIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCB0RXIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCB0RXIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCB0RXIER {
                match value {
                    i => UCB0RXIER::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCB0TXIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCB0TXIER {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCB0TXIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCB0TXIER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCB0TXIER {
                match value {
                    i => UCB0TXIER::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCA0RXIE`"]
        pub enum UCA0RXIEW { }
        impl UCA0RXIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCA0RXIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCA0RXIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCA0RXIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCA0TXIE`"]
        pub enum UCA0TXIEW { }
        impl UCA0TXIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCA0TXIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCA0TXIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCA0TXIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCB0RXIE`"]
        pub enum UCB0RXIEW { }
        impl UCB0RXIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCB0RXIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCB0RXIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCB0RXIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCB0TXIE`"]
        pub enum UCB0TXIEW { }
        impl UCB0TXIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCB0TXIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCB0TXIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCB0TXIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - UCA0RXIE"]
            #[inline(always)]
            pub fn uca0rxie(&self) -> UCA0RXIER {
                UCA0RXIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - UCA0TXIE"]
            #[inline(always)]
            pub fn uca0txie(&self) -> UCA0TXIER {
                UCA0TXIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - UCB0RXIE"]
            #[inline(always)]
            pub fn ucb0rxie(&self) -> UCB0RXIER {
                UCB0RXIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - UCB0TXIE"]
            #[inline(always)]
            pub fn ucb0txie(&self) -> UCB0TXIER {
                UCB0TXIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - UCA0RXIE"]
            #[inline(always)]
            pub fn uca0rxie(&mut self) -> _UCA0RXIEW {
                _UCA0RXIEW { w: self }
            }
            #[doc = "Bit 1 - UCA0TXIE"]
            #[inline(always)]
            pub fn uca0txie(&mut self) -> _UCA0TXIEW {
                _UCA0TXIEW { w: self }
            }
            #[doc = "Bit 2 - UCB0RXIE"]
            #[inline(always)]
            pub fn ucb0rxie(&mut self) -> _UCB0RXIEW {
                _UCB0RXIEW { w: self }
            }
            #[doc = "Bit 3 - UCB0TXIE"]
            #[inline(always)]
            pub fn ucb0txie(&mut self) -> _UCB0TXIEW {
                _UCB0TXIEW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag 1"]
    pub struct IFG1 {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag 1"]
    pub mod ifg1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::IFG1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDTIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl WDTIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTIFGR {
                match value {
                    i => WDTIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `OFIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl OFIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OFIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OFIFGR {
                match value {
                    i => OFIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `PORIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl PORIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PORIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PORIFGR {
                match value {
                    i => PORIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `RSTIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSTIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RSTIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RSTIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RSTIFGR {
                match value {
                    i => RSTIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `NMIIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NMIIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl NMIIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    NMIIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> NMIIFGR {
                match value {
                    i => NMIIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `WDTIFG`"]
        pub enum WDTIFGW { }
        impl WDTIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFIFG`"]
        pub enum OFIFGW { }
        impl OFIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OFIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PORIFG`"]
        pub enum PORIFGW { }
        impl PORIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PORIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSTIFG`"]
        pub enum RSTIFGW { }
        impl RSTIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSTIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSTIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSTIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NMIIFG`"]
        pub enum NMIIFGW { }
        impl NMIIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NMIIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog Interrupt Flag"]
            #[inline(always)]
            pub fn wdtifg(&self) -> WDTIFGR {
                WDTIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Flag"]
            #[inline(always)]
            pub fn ofifg(&self) -> OFIFGR {
                OFIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Power On Interrupt Flag"]
            #[inline(always)]
            pub fn porifg(&self) -> PORIFGR {
                PORIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Reset Interrupt Flag"]
            #[inline(always)]
            pub fn rstifg(&self) -> RSTIFGR {
                RSTIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - NMI Interrupt Flag"]
            #[inline(always)]
            pub fn nmiifg(&self) -> NMIIFGR {
                NMIIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Watchdog Interrupt Flag"]
            #[inline(always)]
            pub fn wdtifg(&mut self) -> _WDTIFGW {
                _WDTIFGW { w: self }
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Flag"]
            #[inline(always)]
            pub fn ofifg(&mut self) -> _OFIFGW {
                _OFIFGW { w: self }
            }
            #[doc = "Bit 2 - Power On Interrupt Flag"]
            #[inline(always)]
            pub fn porifg(&mut self) -> _PORIFGW {
                _PORIFGW { w: self }
            }
            #[doc = "Bit 3 - Reset Interrupt Flag"]
            #[inline(always)]
            pub fn rstifg(&mut self) -> _RSTIFGW {
                _RSTIFGW { w: self }
            }
            #[doc = "Bit 4 - NMI Interrupt Flag"]
            #[inline(always)]
            pub fn nmiifg(&mut self) -> _NMIIFGW {
                _NMIIFGW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag 2"]
    pub struct IFG2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag 2"]
    pub mod ifg2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::IFG2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UCA0RXIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCA0RXIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCA0RXIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCA0RXIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCA0RXIFGR {
                match value {
                    i => UCA0RXIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCA0TXIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCA0TXIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCA0TXIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCA0TXIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCA0TXIFGR {
                match value {
                    i => UCA0TXIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCB0RXIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCB0RXIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCB0RXIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCB0RXIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCB0RXIFGR {
                match value {
                    i => UCB0RXIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `UCB0TXIFG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UCB0TXIFGR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl UCB0TXIFGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UCB0TXIFGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UCB0TXIFGR {
                match value {
                    i => UCB0TXIFGR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `UCA0RXIFG`"]
        pub enum UCA0RXIFGW { }
        impl UCA0RXIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCA0RXIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCA0RXIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCA0RXIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCA0TXIFG`"]
        pub enum UCA0TXIFGW { }
        impl UCA0TXIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCA0TXIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCA0TXIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCA0TXIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCB0RXIFG`"]
        pub enum UCB0RXIFGW { }
        impl UCB0RXIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCB0RXIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCB0RXIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCB0RXIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UCB0TXIFG`"]
        pub enum UCB0TXIFGW { }
        impl UCB0TXIFGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UCB0TXIFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UCB0TXIFGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UCB0TXIFGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - UCA0RXIFG"]
            #[inline(always)]
            pub fn uca0rxifg(&self) -> UCA0RXIFGR {
                UCA0RXIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - UCA0TXIFG"]
            #[inline(always)]
            pub fn uca0txifg(&self) -> UCA0TXIFGR {
                UCA0TXIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - UCB0RXIFG"]
            #[inline(always)]
            pub fn ucb0rxifg(&self) -> UCB0RXIFGR {
                UCB0RXIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - UCB0TXIFG"]
            #[inline(always)]
            pub fn ucb0txifg(&self) -> UCB0TXIFGR {
                UCB0TXIFGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - UCA0RXIFG"]
            #[inline(always)]
            pub fn uca0rxifg(&mut self) -> _UCA0RXIFGW {
                _UCA0RXIFGW { w: self }
            }
            #[doc = "Bit 1 - UCA0TXIFG"]
            #[inline(always)]
            pub fn uca0txifg(&mut self) -> _UCA0TXIFGW {
                _UCA0TXIFGW { w: self }
            }
            #[doc = "Bit 2 - UCB0RXIFG"]
            #[inline(always)]
            pub fn ucb0rxifg(&mut self) -> _UCB0RXIFGW {
                _UCB0RXIFGW { w: self }
            }
            #[doc = "Bit 3 - UCB0TXIFG"]
            #[inline(always)]
            pub fn ucb0txifg(&mut self) -> _UCB0TXIFGW {
                _UCB0TXIFGW { w: self }
            }
        }
    }
}
#[doc = "Special Function"]
pub struct SPECIAL_FUNCTION {
    register_block: special_function::RegisterBlock,
}
impl Deref for SPECIAL_FUNCTION {
    type Target = special_function::RegisterBlock;
    fn deref(&self) -> &special_function::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Port 3/4"]
pub const PORT_3_4: Peripheral<PORT_3_4> = unsafe { Peripheral::new(16) };
#[doc = "Port 3/4"]
pub mod port_3_4 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Port 3 Resistor Enable"]
        pub p3ren: P3REN,
        _reserved0: [u8; 7usize],
        #[doc = "0x08 - Port 3 Input"]
        pub p3in: P3IN,
        #[doc = "0x09 - Port 3 Output"]
        pub p3out: P3OUT,
        #[doc = "0x0a - Port 3 Direction"]
        pub p3dir: P3DIR,
        #[doc = "0x0b - Port 3 Selection"]
        pub p3sel: P3SEL,
        _reserved1: [u8; 39usize],
        #[doc = "0x33 - Port 3 Selection 2"]
        pub p3sel2: P3SEL2,
    }
    #[doc = "Port 3 Resistor Enable"]
    pub struct P3REN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Resistor Enable"]
    pub mod p3ren {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3REN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 3 Input"]
    pub struct P3IN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Input"]
    pub mod p3in {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3IN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 3 Output"]
    pub struct P3OUT {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Output"]
    pub mod p3out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 3 Direction"]
    pub struct P3DIR {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Direction"]
    pub mod p3dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 3 Selection"]
    pub struct P3SEL {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Selection"]
    pub mod p3sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 3 Selection 2"]
    pub struct P3SEL2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 3 Selection 2"]
    pub mod p3sel2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P3SEL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
}
#[doc = "Port 3/4"]
pub struct PORT_3_4 {
    register_block: port_3_4::RegisterBlock,
}
impl Deref for PORT_3_4 {
    type Target = port_3_4::RegisterBlock;
    fn deref(&self) -> &port_3_4::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Calibration Data"]
pub const CALIBRATION_DATA: Peripheral<CALIBRATION_DATA> =
    unsafe { Peripheral::new(4344) };
#[doc = "Calibration Data"]
pub mod calibration_data {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DCOCTL Calibration Data for 16MHz"]
        pub caldco_16mhz: CALDCO_16MHZ,
        #[doc = "0x01 - BCSCTL1 Calibration Data for 16MHz"]
        pub calbc1_16mhz: CALBC1_16MHZ,
        #[doc = "0x02 - DCOCTL Calibration Data for 12MHz"]
        pub caldco_12mhz: CALDCO_12MHZ,
        #[doc = "0x03 - BCSCTL1 Calibration Data for 12MHz"]
        pub calbc1_12mhz: CALBC1_12MHZ,
        #[doc = "0x04 - DCOCTL Calibration Data for 8MHz"]
        pub caldco_8mhz: CALDCO_8MHZ,
        #[doc = "0x05 - BCSCTL1 Calibration Data for 8MHz"]
        pub calbc1_8mhz: CALBC1_8MHZ,
        #[doc = "0x06 - DCOCTL Calibration Data for 1MHz"]
        pub caldco_1mhz: CALDCO_1MHZ,
        #[doc = "0x07 - BCSCTL1 Calibration Data for 1MHz"]
        pub calbc1_1mhz: CALBC1_1MHZ,
    }
    #[doc = "DCOCTL Calibration Data for 16MHz"]
    pub struct CALDCO_16MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "DCOCTL Calibration Data for 16MHz"]
    pub mod caldco_16mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALDCO_16MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "BCSCTL1 Calibration Data for 16MHz"]
    pub struct CALBC1_16MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "BCSCTL1 Calibration Data for 16MHz"]
    pub mod calbc1_16mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALBC1_16MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DCOCTL Calibration Data for 12MHz"]
    pub struct CALDCO_12MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "DCOCTL Calibration Data for 12MHz"]
    pub mod caldco_12mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALDCO_12MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "BCSCTL1 Calibration Data for 12MHz"]
    pub struct CALBC1_12MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "BCSCTL1 Calibration Data for 12MHz"]
    pub mod calbc1_12mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALBC1_12MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DCOCTL Calibration Data for 8MHz"]
    pub struct CALDCO_8MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "DCOCTL Calibration Data for 8MHz"]
    pub mod caldco_8mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALDCO_8MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "BCSCTL1 Calibration Data for 8MHz"]
    pub struct CALBC1_8MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "BCSCTL1 Calibration Data for 8MHz"]
    pub mod calbc1_8mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALBC1_8MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DCOCTL Calibration Data for 1MHz"]
    pub struct CALDCO_1MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "DCOCTL Calibration Data for 1MHz"]
    pub mod caldco_1mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALDCO_1MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "BCSCTL1 Calibration Data for 1MHz"]
    pub struct CALBC1_1MHZ {
        register: VolatileCell<u8>,
    }
    #[doc = "BCSCTL1 Calibration Data for 1MHz"]
    pub mod calbc1_1mhz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CALBC1_1MHZ {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Calibration Data"]
pub struct CALIBRATION_DATA {
    register_block: calibration_data::RegisterBlock,
}
impl Deref for CALIBRATION_DATA {
    type Target = calibration_data::RegisterBlock;
    fn deref(&self) -> &calibration_data::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Port 1/2"]
pub const PORT_1_2: Peripheral<PORT_1_2> = unsafe { Peripheral::new(32) };
#[doc = "Port 1/2"]
pub mod port_1_2 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Port 1 Input"]
        pub p1in: P1IN,
        #[doc = "0x01 - Port 1 Output"]
        pub p1out: P1OUT,
        #[doc = "0x02 - Port 1 Direction"]
        pub p1dir: P1DIR,
        #[doc = "0x03 - Port 1 Interrupt Flag"]
        pub p1ifg: P1IFG,
        #[doc = "0x04 - Port 1 Interrupt Edge Select"]
        pub p1ies: P1IES,
        #[doc = "0x05 - Port 1 Interrupt Enable"]
        pub p1ie: P1IE,
        #[doc = "0x06 - Port 1 Selection"]
        pub p1sel: P1SEL,
        #[doc = "0x07 - Port 1 Resistor Enable"]
        pub p1ren: P1REN,
        #[doc = "0x08 - Port 2 Input"]
        pub p2in: P2IN,
        #[doc = "0x09 - Port 2 Output"]
        pub p2out: P2OUT,
        #[doc = "0x0a - Port 2 Direction"]
        pub p2dir: P2DIR,
        #[doc = "0x0b - Port 2 Interrupt Flag"]
        pub p2ifg: P2IFG,
        #[doc = "0x0c - Port 2 Interrupt Edge Select"]
        pub p2ies: P2IES,
        #[doc = "0x0d - Port 2 Interrupt Enable"]
        pub p2ie: P2IE,
        #[doc = "0x0e - Port 2 Selection"]
        pub p2sel: P2SEL,
        #[doc = "0x0f - Port 2 Resistor Enable"]
        pub p2ren: P2REN,
        _reserved0: [u8; 17usize],
        #[doc = "0x21 - Port 1 Selection 2"]
        pub p1sel2: P1SEL2,
        #[doc = "0x22 - Port 2 Selection 2"]
        pub p2sel2: P2SEL2,
    }
    #[doc = "Port 1 Input"]
    pub struct P1IN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Input"]
    pub mod p1in {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1IN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Output"]
    pub struct P1OUT {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Output"]
    pub mod p1out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Direction"]
    pub struct P1DIR {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Direction"]
    pub mod p1dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Interrupt Flag"]
    pub struct P1IFG {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Interrupt Flag"]
    pub mod p1ifg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1IFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Interrupt Edge Select"]
    pub struct P1IES {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Interrupt Edge Select"]
    pub mod p1ies {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1IES {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Interrupt Enable"]
    pub struct P1IE {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Interrupt Enable"]
    pub mod p1ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Selection"]
    pub struct P1SEL {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Selection"]
    pub mod p1sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Resistor Enable"]
    pub struct P1REN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Resistor Enable"]
    pub mod p1ren {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1REN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Input"]
    pub struct P2IN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Input"]
    pub mod p2in {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2IN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Output"]
    pub struct P2OUT {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Output"]
    pub mod p2out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Direction"]
    pub struct P2DIR {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Direction"]
    pub mod p2dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Interrupt Flag"]
    pub struct P2IFG {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Interrupt Flag"]
    pub mod p2ifg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2IFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Interrupt Edge Select"]
    pub struct P2IES {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Interrupt Edge Select"]
    pub mod p2ies {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2IES {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Interrupt Enable"]
    pub struct P2IE {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Interrupt Enable"]
    pub mod p2ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Selection"]
    pub struct P2SEL {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Selection"]
    pub mod p2sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Resistor Enable"]
    pub struct P2REN {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Resistor Enable"]
    pub mod p2ren {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2REN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 1 Selection 2"]
    pub struct P1SEL2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 1 Selection 2"]
    pub mod p1sel2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P1SEL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
    #[doc = "Port 2 Selection 2"]
    pub struct P2SEL2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Port 2 Selection 2"]
    pub mod p2sel2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::P2SEL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `P0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P0R {
                match value {
                    i => P0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P1R {
                match value {
                    i => P1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P2R {
                match value {
                    i => P2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P3R {
                match value {
                    i => P3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P4R {
                match value {
                    i => P4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P5R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P5R {
                match value {
                    i => P5R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P6R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P6R {
                match value {
                    i => P6R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `P7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum P7R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl P7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    P7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> P7R {
                match value {
                    i => P7R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `P0`"]
        pub enum P0W { }
        impl P0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P1`"]
        pub enum P1W { }
        impl P1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P2`"]
        pub enum P2W { }
        impl P2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P3`"]
        pub enum P3W { }
        impl P3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P4`"]
        pub enum P4W { }
        impl P4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P5`"]
        pub enum P5W { }
        impl P5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P6`"]
        pub enum P6W { }
        impl P6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `P7`"]
        pub enum P7W { }
        impl P7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _P7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: P7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> _P0W {
                _P0W { w: self }
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> _P1W {
                _P1W { w: self }
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> _P2W {
                _P2W { w: self }
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> _P3W {
                _P3W { w: self }
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> _P4W {
                _P4W { w: self }
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> _P5W {
                _P5W { w: self }
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> _P6W {
                _P6W { w: self }
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> _P7W {
                _P7W { w: self }
            }
        }
    }
}
#[doc = "Port 1/2"]
pub struct PORT_1_2 {
    register_block: port_1_2::RegisterBlock,
}
impl Deref for PORT_1_2 {
    type Target = port_1_2::RegisterBlock;
    fn deref(&self) -> &port_1_2::RegisterBlock {
        &self.register_block
    }
}
#[doc = "System Clock"]
pub const SYSTEM_CLOCK: Peripheral<SYSTEM_CLOCK> =
    unsafe { Peripheral::new(82) };
#[doc = "System Clock"]
pub mod system_clock {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1usize],
        #[doc = "0x01 - Basic Clock System Control 3"]
        pub bcsctl3: BCSCTL3,
        _reserved1: [u8; 2usize],
        #[doc = "0x04 - DCO Clock Frequency Control"]
        pub dcoctl: DCOCTL,
        #[doc = "0x05 - Basic Clock System Control 1"]
        pub bcsctl1: BCSCTL1,
        #[doc = "0x06 - Basic Clock System Control 2"]
        pub bcsctl2: BCSCTL2,
    }
    #[doc = "Basic Clock System Control 3"]
    pub struct BCSCTL3 {
        register: VolatileCell<u8>,
    }
    #[doc = "Basic Clock System Control 3"]
    pub mod bcsctl3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::BCSCTL3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LFXT1OF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LFXT1OFR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl LFXT1OFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LFXT1OFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LFXT1OFR {
                match value {
                    i => LFXT1OFR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `XT2OF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XT2OFR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl XT2OFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    XT2OFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> XT2OFR {
                match value {
                    i => XT2OFR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `XCAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XCAPR {
            #[doc = "XIN/XOUT Cap : 0 pF"]
            XCAP_0,
            #[doc = "XIN/XOUT Cap : 6 pF"]
            XCAP_1,
            #[doc = "XIN/XOUT Cap : 10 pF"]
            XCAP_2,
            #[doc = "XIN/XOUT Cap : 12.5 pF"]
            XCAP_3,
        }
        impl XCAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    XCAPR::XCAP_0 => 0,
                    XCAPR::XCAP_1 => 1,
                    XCAPR::XCAP_2 => 2,
                    XCAPR::XCAP_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> XCAPR {
                match value {
                    0 => XCAPR::XCAP_0,
                    1 => XCAPR::XCAP_1,
                    2 => XCAPR::XCAP_2,
                    3 => XCAPR::XCAP_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `XCAP_0`"]
            #[inline(always)]
            pub fn is_xcap_0(&self) -> bool {
                *self == XCAPR::XCAP_0
            }
            #[doc = "Checks if the value of the field is `XCAP_1`"]
            #[inline(always)]
            pub fn is_xcap_1(&self) -> bool {
                *self == XCAPR::XCAP_1
            }
            #[doc = "Checks if the value of the field is `XCAP_2`"]
            #[inline(always)]
            pub fn is_xcap_2(&self) -> bool {
                *self == XCAPR::XCAP_2
            }
            #[doc = "Checks if the value of the field is `XCAP_3`"]
            #[inline(always)]
            pub fn is_xcap_3(&self) -> bool {
                *self == XCAPR::XCAP_3
            }
        }
        #[doc = "Possible values of the field `LFXT1S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LFXT1SR {
            #[doc = "Mode 0 for LFXT1 : Normal operation"]
            LFXT1S_0,
            #[doc = "Mode 1 for LFXT1 : Reserved"]
            LFXT1S_1,
            #[doc = "Mode 2 for LFXT1 : VLO"]
            LFXT1S_2,
            #[doc = "Mode 3 for LFXT1 : Digital input signal"]
            LFXT1S_3,
        }
        impl LFXT1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    LFXT1SR::LFXT1S_0 => 0,
                    LFXT1SR::LFXT1S_1 => 1,
                    LFXT1SR::LFXT1S_2 => 2,
                    LFXT1SR::LFXT1S_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> LFXT1SR {
                match value {
                    0 => LFXT1SR::LFXT1S_0,
                    1 => LFXT1SR::LFXT1S_1,
                    2 => LFXT1SR::LFXT1S_2,
                    3 => LFXT1SR::LFXT1S_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LFXT1S_0`"]
            #[inline(always)]
            pub fn is_lfxt1s_0(&self) -> bool {
                *self == LFXT1SR::LFXT1S_0
            }
            #[doc = "Checks if the value of the field is `LFXT1S_1`"]
            #[inline(always)]
            pub fn is_lfxt1s_1(&self) -> bool {
                *self == LFXT1SR::LFXT1S_1
            }
            #[doc = "Checks if the value of the field is `LFXT1S_2`"]
            #[inline(always)]
            pub fn is_lfxt1s_2(&self) -> bool {
                *self == LFXT1SR::LFXT1S_2
            }
            #[doc = "Checks if the value of the field is `LFXT1S_3`"]
            #[inline(always)]
            pub fn is_lfxt1s_3(&self) -> bool {
                *self == LFXT1SR::LFXT1S_3
            }
        }
        #[doc = "Possible values of the field `XT2S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XT2SR {
            #[doc = "Mode 0 for XT2 : 0.4 - 1 MHz"]
            XT2S_0,
            #[doc = "Mode 1 for XT2 : 1 - 4 MHz"]
            XT2S_1,
            #[doc = "Mode 2 for XT2 : 2 - 16 MHz"]
            XT2S_2,
            #[doc = "Mode 3 for XT2 : Digital input signal"]
            XT2S_3,
        }
        impl XT2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    XT2SR::XT2S_0 => 0,
                    XT2SR::XT2S_1 => 1,
                    XT2SR::XT2S_2 => 2,
                    XT2SR::XT2S_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> XT2SR {
                match value {
                    0 => XT2SR::XT2S_0,
                    1 => XT2SR::XT2S_1,
                    2 => XT2SR::XT2S_2,
                    3 => XT2SR::XT2S_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `XT2S_0`"]
            #[inline(always)]
            pub fn is_xt2s_0(&self) -> bool {
                *self == XT2SR::XT2S_0
            }
            #[doc = "Checks if the value of the field is `XT2S_1`"]
            #[inline(always)]
            pub fn is_xt2s_1(&self) -> bool {
                *self == XT2SR::XT2S_1
            }
            #[doc = "Checks if the value of the field is `XT2S_2`"]
            #[inline(always)]
            pub fn is_xt2s_2(&self) -> bool {
                *self == XT2SR::XT2S_2
            }
            #[doc = "Checks if the value of the field is `XT2S_3`"]
            #[inline(always)]
            pub fn is_xt2s_3(&self) -> bool {
                *self == XT2SR::XT2S_3
            }
        }
        #[doc = "Values that can be written to the field `LFXT1OF`"]
        pub enum LFXT1OFW { }
        impl LFXT1OFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LFXT1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LFXT1OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LFXT1OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XT2OF`"]
        pub enum XT2OFW { }
        impl XT2OFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XT2OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XT2OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XT2OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XCAP`"]
        pub enum XCAPW {
            #[doc = "XIN/XOUT Cap : 0 pF"]
            XCAP_0,
            #[doc = "XIN/XOUT Cap : 6 pF"]
            XCAP_1,
            #[doc = "XIN/XOUT Cap : 10 pF"]
            XCAP_2,
            #[doc = "XIN/XOUT Cap : 12.5 pF"]
            XCAP_3,
        }
        impl XCAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XCAPW::XCAP_0 => 0,
                    XCAPW::XCAP_1 => 1,
                    XCAPW::XCAP_2 => 2,
                    XCAPW::XCAP_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XCAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XCAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XCAPW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "XIN/XOUT Cap : 0 pF"]
            #[inline(always)]
            pub fn xcap_0(self) -> &'a mut W {
                self.variant(XCAPW::XCAP_0)
            }
            #[doc = "XIN/XOUT Cap : 6 pF"]
            #[inline(always)]
            pub fn xcap_1(self) -> &'a mut W {
                self.variant(XCAPW::XCAP_1)
            }
            #[doc = "XIN/XOUT Cap : 10 pF"]
            #[inline(always)]
            pub fn xcap_2(self) -> &'a mut W {
                self.variant(XCAPW::XCAP_2)
            }
            #[doc = "XIN/XOUT Cap : 12.5 pF"]
            #[inline(always)]
            pub fn xcap_3(self) -> &'a mut W {
                self.variant(XCAPW::XCAP_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LFXT1S`"]
        pub enum LFXT1SW {
            #[doc = "Mode 0 for LFXT1 : Normal operation"]
            LFXT1S_0,
            #[doc = "Mode 1 for LFXT1 : Reserved"]
            LFXT1S_1,
            #[doc = "Mode 2 for LFXT1 : VLO"]
            LFXT1S_2,
            #[doc = "Mode 3 for LFXT1 : Digital input signal"]
            LFXT1S_3,
        }
        impl LFXT1SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LFXT1SW::LFXT1S_0 => 0,
                    LFXT1SW::LFXT1S_1 => 1,
                    LFXT1SW::LFXT1S_2 => 2,
                    LFXT1SW::LFXT1S_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LFXT1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LFXT1SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LFXT1SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Mode 0 for LFXT1 : Normal operation"]
            #[inline(always)]
            pub fn lfxt1s_0(self) -> &'a mut W {
                self.variant(LFXT1SW::LFXT1S_0)
            }
            #[doc = "Mode 1 for LFXT1 : Reserved"]
            #[inline(always)]
            pub fn lfxt1s_1(self) -> &'a mut W {
                self.variant(LFXT1SW::LFXT1S_1)
            }
            #[doc = "Mode 2 for LFXT1 : VLO"]
            #[inline(always)]
            pub fn lfxt1s_2(self) -> &'a mut W {
                self.variant(LFXT1SW::LFXT1S_2)
            }
            #[doc = "Mode 3 for LFXT1 : Digital input signal"]
            #[inline(always)]
            pub fn lfxt1s_3(self) -> &'a mut W {
                self.variant(LFXT1SW::LFXT1S_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XT2S`"]
        pub enum XT2SW {
            #[doc = "Mode 0 for XT2 : 0.4 - 1 MHz"]
            XT2S_0,
            #[doc = "Mode 1 for XT2 : 1 - 4 MHz"]
            XT2S_1,
            #[doc = "Mode 2 for XT2 : 2 - 16 MHz"]
            XT2S_2,
            #[doc = "Mode 3 for XT2 : Digital input signal"]
            XT2S_3,
        }
        impl XT2SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XT2SW::XT2S_0 => 0,
                    XT2SW::XT2S_1 => 1,
                    XT2SW::XT2S_2 => 2,
                    XT2SW::XT2S_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XT2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XT2SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XT2SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Mode 0 for XT2 : 0.4 - 1 MHz"]
            #[inline(always)]
            pub fn xt2s_0(self) -> &'a mut W {
                self.variant(XT2SW::XT2S_0)
            }
            #[doc = "Mode 1 for XT2 : 1 - 4 MHz"]
            #[inline(always)]
            pub fn xt2s_1(self) -> &'a mut W {
                self.variant(XT2SW::XT2S_1)
            }
            #[doc = "Mode 2 for XT2 : 2 - 16 MHz"]
            #[inline(always)]
            pub fn xt2s_2(self) -> &'a mut W {
                self.variant(XT2SW::XT2S_2)
            }
            #[doc = "Mode 3 for XT2 : Digital input signal"]
            #[inline(always)]
            pub fn xt2s_3(self) -> &'a mut W {
                self.variant(XT2SW::XT2S_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Low/high Frequency Oscillator Fault Flag"]
            #[inline(always)]
            pub fn lfxt1of(&self) -> LFXT1OFR {
                LFXT1OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - High frequency oscillator 2 fault flag"]
            #[inline(always)]
            pub fn xt2of(&self) -> XT2OFR {
                XT2OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 2:3 - XIN/XOUT Cap 0"]
            #[inline(always)]
            pub fn xcap(&self) -> XCAPR {
                XCAPR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:5 - Mode 0 for LFXT1 (XTS = 0)"]
            #[inline(always)]
            pub fn lfxt1s(&self) -> LFXT1SR {
                LFXT1SR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 6:7 - Mode 0 for XT2"]
            #[inline(always)]
            pub fn xt2s(&self) -> XT2SR {
                XT2SR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Low/high Frequency Oscillator Fault Flag"]
            #[inline(always)]
            pub fn lfxt1of(&mut self) -> _LFXT1OFW {
                _LFXT1OFW { w: self }
            }
            #[doc = "Bit 1 - High frequency oscillator 2 fault flag"]
            #[inline(always)]
            pub fn xt2of(&mut self) -> _XT2OFW {
                _XT2OFW { w: self }
            }
            #[doc = "Bits 2:3 - XIN/XOUT Cap 0"]
            #[inline(always)]
            pub fn xcap(&mut self) -> _XCAPW {
                _XCAPW { w: self }
            }
            #[doc = "Bits 4:5 - Mode 0 for LFXT1 (XTS = 0)"]
            #[inline(always)]
            pub fn lfxt1s(&mut self) -> _LFXT1SW {
                _LFXT1SW { w: self }
            }
            #[doc = "Bits 6:7 - Mode 0 for XT2"]
            #[inline(always)]
            pub fn xt2s(&mut self) -> _XT2SW {
                _XT2SW { w: self }
            }
        }
    }
    #[doc = "DCO Clock Frequency Control"]
    pub struct DCOCTL {
        register: VolatileCell<u8>,
    }
    #[doc = "DCO Clock Frequency Control"]
    pub mod dcoctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DCOCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MOD0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOD0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MOD0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MOD0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MOD0R {
                match value {
                    i => MOD0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MOD1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOD1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MOD1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MOD1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MOD1R {
                match value {
                    i => MOD1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MOD2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOD2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MOD2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MOD2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MOD2R {
                match value {
                    i => MOD2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MOD3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOD3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MOD3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MOD3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MOD3R {
                match value {
                    i => MOD3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `MOD4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOD4R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl MOD4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MOD4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MOD4R {
                match value {
                    i => MOD4R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `DCO0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCO0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl DCO0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    DCO0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> DCO0R {
                match value {
                    i => DCO0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `DCO1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCO1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl DCO1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    DCO1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> DCO1R {
                match value {
                    i => DCO1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `DCO2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCO2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl DCO2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    DCO2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> DCO2R {
                match value {
                    i => DCO2R::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `MOD0`"]
        pub enum MOD0W { }
        impl MOD0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOD0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOD0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MOD1`"]
        pub enum MOD1W { }
        impl MOD1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOD1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOD1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MOD2`"]
        pub enum MOD2W { }
        impl MOD2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOD2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOD2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MOD3`"]
        pub enum MOD3W { }
        impl MOD3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOD3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOD3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MOD4`"]
        pub enum MOD4W { }
        impl MOD4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOD4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOD4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DCO0`"]
        pub enum DCO0W { }
        impl DCO0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCO0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DCO0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DCO1`"]
        pub enum DCO1W { }
        impl DCO1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCO1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DCO1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DCO2`"]
        pub enum DCO2W { }
        impl DCO2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCO2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCO2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DCO2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Modulation Bit 0"]
            #[inline(always)]
            pub fn mod0(&self) -> MOD0R {
                MOD0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Modulation Bit 1"]
            #[inline(always)]
            pub fn mod1(&self) -> MOD1R {
                MOD1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Modulation Bit 2"]
            #[inline(always)]
            pub fn mod2(&self) -> MOD2R {
                MOD2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Modulation Bit 3"]
            #[inline(always)]
            pub fn mod3(&self) -> MOD3R {
                MOD3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 4 - Modulation Bit 4"]
            #[inline(always)]
            pub fn mod4(&self) -> MOD4R {
                MOD4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 5 - DCO Select Bit 0"]
            #[inline(always)]
            pub fn dco0(&self) -> DCO0R {
                DCO0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 6 - DCO Select Bit 1"]
            #[inline(always)]
            pub fn dco1(&self) -> DCO1R {
                DCO1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - DCO Select Bit 2"]
            #[inline(always)]
            pub fn dco2(&self) -> DCO2R {
                DCO2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Modulation Bit 0"]
            #[inline(always)]
            pub fn mod0(&mut self) -> _MOD0W {
                _MOD0W { w: self }
            }
            #[doc = "Bit 1 - Modulation Bit 1"]
            #[inline(always)]
            pub fn mod1(&mut self) -> _MOD1W {
                _MOD1W { w: self }
            }
            #[doc = "Bit 2 - Modulation Bit 2"]
            #[inline(always)]
            pub fn mod2(&mut self) -> _MOD2W {
                _MOD2W { w: self }
            }
            #[doc = "Bit 3 - Modulation Bit 3"]
            #[inline(always)]
            pub fn mod3(&mut self) -> _MOD3W {
                _MOD3W { w: self }
            }
            #[doc = "Bit 4 - Modulation Bit 4"]
            #[inline(always)]
            pub fn mod4(&mut self) -> _MOD4W {
                _MOD4W { w: self }
            }
            #[doc = "Bit 5 - DCO Select Bit 0"]
            #[inline(always)]
            pub fn dco0(&mut self) -> _DCO0W {
                _DCO0W { w: self }
            }
            #[doc = "Bit 6 - DCO Select Bit 1"]
            #[inline(always)]
            pub fn dco1(&mut self) -> _DCO1W {
                _DCO1W { w: self }
            }
            #[doc = "Bit 7 - DCO Select Bit 2"]
            #[inline(always)]
            pub fn dco2(&mut self) -> _DCO2W {
                _DCO2W { w: self }
            }
        }
    }
    #[doc = "Basic Clock System Control 1"]
    pub struct BCSCTL1 {
        register: VolatileCell<u8>,
    }
    #[doc = "Basic Clock System Control 1"]
    pub mod bcsctl1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::BCSCTL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RSEL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSEL0R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RSEL0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RSEL0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RSEL0R {
                match value {
                    i => RSEL0R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `RSEL1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSEL1R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RSEL1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RSEL1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RSEL1R {
                match value {
                    i => RSEL1R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `RSEL2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSEL2R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RSEL2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RSEL2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RSEL2R {
                match value {
                    i => RSEL2R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `RSEL3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSEL3R {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RSEL3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RSEL3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RSEL3R {
                match value {
                    i => RSEL3R::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `DIVA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIVAR {
            #[doc = "ACLK Divider 0: /1"]
            DIVA_0,
            #[doc = "ACLK Divider 1: /2"]
            DIVA_1,
            #[doc = "ACLK Divider 2: /4"]
            DIVA_2,
            #[doc = "ACLK Divider 3: /8"]
            DIVA_3,
        }
        impl DIVAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIVAR::DIVA_0 => 0,
                    DIVAR::DIVA_1 => 1,
                    DIVAR::DIVA_2 => 2,
                    DIVAR::DIVA_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIVAR {
                match value {
                    0 => DIVAR::DIVA_0,
                    1 => DIVAR::DIVA_1,
                    2 => DIVAR::DIVA_2,
                    3 => DIVAR::DIVA_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVA_0`"]
            #[inline(always)]
            pub fn is_diva_0(&self) -> bool {
                *self == DIVAR::DIVA_0
            }
            #[doc = "Checks if the value of the field is `DIVA_1`"]
            #[inline(always)]
            pub fn is_diva_1(&self) -> bool {
                *self == DIVAR::DIVA_1
            }
            #[doc = "Checks if the value of the field is `DIVA_2`"]
            #[inline(always)]
            pub fn is_diva_2(&self) -> bool {
                *self == DIVAR::DIVA_2
            }
            #[doc = "Checks if the value of the field is `DIVA_3`"]
            #[inline(always)]
            pub fn is_diva_3(&self) -> bool {
                *self == DIVAR::DIVA_3
            }
        }
        #[doc = "Possible values of the field `XTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl XTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    XTSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> XTSR {
                match value {
                    i => XTSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `XT2OFF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XT2OFFR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl XT2OFFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    XT2OFFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> XT2OFFR {
                match value {
                    i => XT2OFFR::_Reserved(i),
                }
            }
        }
        #[doc = "Values that can be written to the field `RSEL0`"]
        pub enum RSEL0W { }
        impl RSEL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSEL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSEL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSEL0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSEL1`"]
        pub enum RSEL1W { }
        impl RSEL1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSEL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSEL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSEL1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSEL2`"]
        pub enum RSEL2W { }
        impl RSEL2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSEL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSEL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSEL2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSEL3`"]
        pub enum RSEL3W { }
        impl RSEL3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSEL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSEL3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSEL3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIVA`"]
        pub enum DIVAW {
            #[doc = "ACLK Divider 0: /1"]
            DIVA_0,
            #[doc = "ACLK Divider 1: /2"]
            DIVA_1,
            #[doc = "ACLK Divider 2: /4"]
            DIVA_2,
            #[doc = "ACLK Divider 3: /8"]
            DIVA_3,
        }
        impl DIVAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIVAW::DIVA_0 => 0,
                    DIVAW::DIVA_1 => 1,
                    DIVAW::DIVA_2 => 2,
                    DIVAW::DIVA_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIVAW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "ACLK Divider 0: /1"]
            #[inline(always)]
            pub fn diva_0(self) -> &'a mut W {
                self.variant(DIVAW::DIVA_0)
            }
            #[doc = "ACLK Divider 1: /2"]
            #[inline(always)]
            pub fn diva_1(self) -> &'a mut W {
                self.variant(DIVAW::DIVA_1)
            }
            #[doc = "ACLK Divider 2: /4"]
            #[inline(always)]
            pub fn diva_2(self) -> &'a mut W {
                self.variant(DIVAW::DIVA_2)
            }
            #[doc = "ACLK Divider 3: /8"]
            #[inline(always)]
            pub fn diva_3(self) -> &'a mut W {
                self.variant(DIVAW::DIVA_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XTS`"]
        pub enum XTSW { }
        impl XTSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XTSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XT2OFF`"]
        pub enum XT2OFFW { }
        impl XT2OFFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XT2OFFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XT2OFFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XT2OFFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Range Select Bit 0"]
            #[inline(always)]
            pub fn rsel0(&self) -> RSEL0R {
                RSEL0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 1 - Range Select Bit 1"]
            #[inline(always)]
            pub fn rsel1(&self) -> RSEL1R {
                RSEL1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 2 - Range Select Bit 2"]
            #[inline(always)]
            pub fn rsel2(&self) -> RSEL2R {
                RSEL2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 3 - Range Select Bit 3"]
            #[inline(always)]
            pub fn rsel3(&self) -> RSEL3R {
                RSEL3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 4:5 - ACLK Divider 0"]
            #[inline(always)]
            pub fn diva(&self) -> DIVAR {
                DIVAR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 6 - LFXTCLK 0:Low Freq. / 1: High Freq."]
            #[inline(always)]
            pub fn xts(&self) -> XTSR {
                XTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bit 7 - Enable XT2CLK"]
            #[inline(always)]
            pub fn xt2off(&self) -> XT2OFFR {
                XT2OFFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Range Select Bit 0"]
            #[inline(always)]
            pub fn rsel0(&mut self) -> _RSEL0W {
                _RSEL0W { w: self }
            }
            #[doc = "Bit 1 - Range Select Bit 1"]
            #[inline(always)]
            pub fn rsel1(&mut self) -> _RSEL1W {
                _RSEL1W { w: self }
            }
            #[doc = "Bit 2 - Range Select Bit 2"]
            #[inline(always)]
            pub fn rsel2(&mut self) -> _RSEL2W {
                _RSEL2W { w: self }
            }
            #[doc = "Bit 3 - Range Select Bit 3"]
            #[inline(always)]
            pub fn rsel3(&mut self) -> _RSEL3W {
                _RSEL3W { w: self }
            }
            #[doc = "Bits 4:5 - ACLK Divider 0"]
            #[inline(always)]
            pub fn diva(&mut self) -> _DIVAW {
                _DIVAW { w: self }
            }
            #[doc = "Bit 6 - LFXTCLK 0:Low Freq. / 1: High Freq."]
            #[inline(always)]
            pub fn xts(&mut self) -> _XTSW {
                _XTSW { w: self }
            }
            #[doc = "Bit 7 - Enable XT2CLK"]
            #[inline(always)]
            pub fn xt2off(&mut self) -> _XT2OFFW {
                _XT2OFFW { w: self }
            }
        }
    }
    #[doc = "Basic Clock System Control 2"]
    pub struct BCSCTL2 {
        register: VolatileCell<u8>,
    }
    #[doc = "Basic Clock System Control 2"]
    pub mod bcsctl2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::BCSCTL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DIVS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIVSR {
            #[doc = "SMCLK Divider 0: /1"]
            DIVS_0,
            #[doc = "SMCLK Divider 1: /2"]
            DIVS_1,
            #[doc = "SMCLK Divider 2: /4"]
            DIVS_2,
            #[doc = "SMCLK Divider 3: /8"]
            DIVS_3,
        }
        impl DIVSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIVSR::DIVS_0 => 0,
                    DIVSR::DIVS_1 => 1,
                    DIVSR::DIVS_2 => 2,
                    DIVSR::DIVS_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIVSR {
                match value {
                    0 => DIVSR::DIVS_0,
                    1 => DIVSR::DIVS_1,
                    2 => DIVSR::DIVS_2,
                    3 => DIVSR::DIVS_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVS_0`"]
            #[inline(always)]
            pub fn is_divs_0(&self) -> bool {
                *self == DIVSR::DIVS_0
            }
            #[doc = "Checks if the value of the field is `DIVS_1`"]
            #[inline(always)]
            pub fn is_divs_1(&self) -> bool {
                *self == DIVSR::DIVS_1
            }
            #[doc = "Checks if the value of the field is `DIVS_2`"]
            #[inline(always)]
            pub fn is_divs_2(&self) -> bool {
                *self == DIVSR::DIVS_2
            }
            #[doc = "Checks if the value of the field is `DIVS_3`"]
            #[inline(always)]
            pub fn is_divs_3(&self) -> bool {
                *self == DIVSR::DIVS_3
            }
        }
        #[doc = "Possible values of the field `SELS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELSR {
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl SELSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SELSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SELSR {
                match value {
                    i => SELSR::_Reserved(i),
                }
            }
        }
        #[doc = "Possible values of the field `DIVM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIVMR {
            #[doc = "MCLK Divider 0: /1"]
            DIVM_0,
            #[doc = "MCLK Divider 1: /2"]
            DIVM_1,
            #[doc = "MCLK Divider 2: /4"]
            DIVM_2,
            #[doc = "MCLK Divider 3: /8"]
            DIVM_3,
        }
        impl DIVMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIVMR::DIVM_0 => 0,
                    DIVMR::DIVM_1 => 1,
                    DIVMR::DIVM_2 => 2,
                    DIVMR::DIVM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIVMR {
                match value {
                    0 => DIVMR::DIVM_0,
                    1 => DIVMR::DIVM_1,
                    2 => DIVMR::DIVM_2,
                    3 => DIVMR::DIVM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVM_0`"]
            #[inline(always)]
            pub fn is_divm_0(&self) -> bool {
                *self == DIVMR::DIVM_0
            }
            #[doc = "Checks if the value of the field is `DIVM_1`"]
            #[inline(always)]
            pub fn is_divm_1(&self) -> bool {
                *self == DIVMR::DIVM_1
            }
            #[doc = "Checks if the value of the field is `DIVM_2`"]
            #[inline(always)]
            pub fn is_divm_2(&self) -> bool {
                *self == DIVMR::DIVM_2
            }
            #[doc = "Checks if the value of the field is `DIVM_3`"]
            #[inline(always)]
            pub fn is_divm_3(&self) -> bool {
                *self == DIVMR::DIVM_3
            }
        }
        #[doc = "Possible values of the field `SELM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELMR {
            #[doc = "MCLK Source Select 0: DCOCLK"]
            SELM_0,
            #[doc = "MCLK Source Select 1: DCOCLK"]
            SELM_1,
            #[doc = "MCLK Source Select 2: XT2CLK/LFXTCLK"]
            SELM_2,
            #[doc = "MCLK Source Select 3: LFXTCLK"]
            SELM_3,
        }
        impl SELMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELMR::SELM_0 => 0,
                    SELMR::SELM_1 => 1,
                    SELMR::SELM_2 => 2,
                    SELMR::SELM_3 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SELMR {
                match value {
                    0 => SELMR::SELM_0,
                    1 => SELMR::SELM_1,
                    2 => SELMR::SELM_2,
                    3 => SELMR::SELM_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SELM_0`"]
            #[inline(always)]
            pub fn is_selm_0(&self) -> bool {
                *self == SELMR::SELM_0
            }
            #[doc = "Checks if the value of the field is `SELM_1`"]
            #[inline(always)]
            pub fn is_selm_1(&self) -> bool {
                *self == SELMR::SELM_1
            }
            #[doc = "Checks if the value of the field is `SELM_2`"]
            #[inline(always)]
            pub fn is_selm_2(&self) -> bool {
                *self == SELMR::SELM_2
            }
            #[doc = "Checks if the value of the field is `SELM_3`"]
            #[inline(always)]
            pub fn is_selm_3(&self) -> bool {
                *self == SELMR::SELM_3
            }
        }
        #[doc = "Values that can be written to the field `DIVS`"]
        pub enum DIVSW {
            #[doc = "SMCLK Divider 0: /1"]
            DIVS_0,
            #[doc = "SMCLK Divider 1: /2"]
            DIVS_1,
            #[doc = "SMCLK Divider 2: /4"]
            DIVS_2,
            #[doc = "SMCLK Divider 3: /8"]
            DIVS_3,
        }
        impl DIVSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIVSW::DIVS_0 => 0,
                    DIVSW::DIVS_1 => 1,
                    DIVSW::DIVS_2 => 2,
                    DIVSW::DIVS_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIVSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "SMCLK Divider 0: /1"]
            #[inline(always)]
            pub fn divs_0(self) -> &'a mut W {
                self.variant(DIVSW::DIVS_0)
            }
            #[doc = "SMCLK Divider 1: /2"]
            #[inline(always)]
            pub fn divs_1(self) -> &'a mut W {
                self.variant(DIVSW::DIVS_1)
            }
            #[doc = "SMCLK Divider 2: /4"]
            #[inline(always)]
            pub fn divs_2(self) -> &'a mut W {
                self.variant(DIVSW::DIVS_2)
            }
            #[doc = "SMCLK Divider 3: /8"]
            #[inline(always)]
            pub fn divs_3(self) -> &'a mut W {
                self.variant(DIVSW::DIVS_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SELS`"]
        pub enum SELSW { }
        impl SELSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match * self { }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SELSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIVM`"]
        pub enum DIVMW {
            #[doc = "MCLK Divider 0: /1"]
            DIVM_0,
            #[doc = "MCLK Divider 1: /2"]
            DIVM_1,
            #[doc = "MCLK Divider 2: /4"]
            DIVM_2,
            #[doc = "MCLK Divider 3: /8"]
            DIVM_3,
        }
        impl DIVMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIVMW::DIVM_0 => 0,
                    DIVMW::DIVM_1 => 1,
                    DIVMW::DIVM_2 => 2,
                    DIVMW::DIVM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIVMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "MCLK Divider 0: /1"]
            #[inline(always)]
            pub fn divm_0(self) -> &'a mut W {
                self.variant(DIVMW::DIVM_0)
            }
            #[doc = "MCLK Divider 1: /2"]
            #[inline(always)]
            pub fn divm_1(self) -> &'a mut W {
                self.variant(DIVMW::DIVM_1)
            }
            #[doc = "MCLK Divider 2: /4"]
            #[inline(always)]
            pub fn divm_2(self) -> &'a mut W {
                self.variant(DIVMW::DIVM_2)
            }
            #[doc = "MCLK Divider 3: /8"]
            #[inline(always)]
            pub fn divm_3(self) -> &'a mut W {
                self.variant(DIVMW::DIVM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SELM`"]
        pub enum SELMW {
            #[doc = "MCLK Source Select 0: DCOCLK"]
            SELM_0,
            #[doc = "MCLK Source Select 1: DCOCLK"]
            SELM_1,
            #[doc = "MCLK Source Select 2: XT2CLK/LFXTCLK"]
            SELM_2,
            #[doc = "MCLK Source Select 3: LFXTCLK"]
            SELM_3,
        }
        impl SELMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELMW::SELM_0 => 0,
                    SELMW::SELM_1 => 1,
                    SELMW::SELM_2 => 2,
                    SELMW::SELM_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SELMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "MCLK Source Select 0: DCOCLK"]
            #[inline(always)]
            pub fn selm_0(self) -> &'a mut W {
                self.variant(SELMW::SELM_0)
            }
            #[doc = "MCLK Source Select 1: DCOCLK"]
            #[inline(always)]
            pub fn selm_1(self) -> &'a mut W {
                self.variant(SELMW::SELM_1)
            }
            #[doc = "MCLK Source Select 2: XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn selm_2(self) -> &'a mut W {
                self.variant(SELMW::SELM_2)
            }
            #[doc = "MCLK Source Select 3: LFXTCLK"]
            #[inline(always)]
            pub fn selm_3(self) -> &'a mut W {
                self.variant(SELMW::SELM_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 1:2 - SMCLK Divider 0"]
            #[inline(always)]
            pub fn divs(&self) -> DIVSR {
                DIVSR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn sels(&self) -> SELSR {
                SELSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                })
            }
            #[doc = "Bits 4:5 - MCLK Divider 0"]
            #[inline(always)]
            pub fn divm(&self) -> DIVMR {
                DIVMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 6:7 - MCLK Source Select 0"]
            #[inline(always)]
            pub fn selm(&self) -> SELMR {
                SELMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:2 - SMCLK Divider 0"]
            #[inline(always)]
            pub fn divs(&mut self) -> _DIVSW {
                _DIVSW { w: self }
            }
            #[doc = "Bit 3 - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn sels(&mut self) -> _SELSW {
                _SELSW { w: self }
            }
            #[doc = "Bits 4:5 - MCLK Divider 0"]
            #[inline(always)]
            pub fn divm(&mut self) -> _DIVMW {
                _DIVMW { w: self }
            }
            #[doc = "Bits 6:7 - MCLK Source Select 0"]
            #[inline(always)]
            pub fn selm(&mut self) -> _SELMW {
                _SELMW { w: self }
            }
        }
    }
}
#[doc = "System Clock"]
pub struct SYSTEM_CLOCK {
    register_block: system_clock::RegisterBlock,
}
impl Deref for SYSTEM_CLOCK {
    type Target = system_clock::RegisterBlock;
    fn deref(&self) -> &system_clock::RegisterBlock {
        &self.register_block
    }
}
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals<'a> {
    #[doc = "FLASH"]
    pub FLASH: &'a FLASH,
    #[doc = "USCI_A0_UART_MODE"]
    pub USCI_A0_UART_MODE: &'a USCI_A0_UART_MODE,
    #[doc = "WATCHDOG_TIMER"]
    pub WATCHDOG_TIMER: &'a WATCHDOG_TIMER,
    #[doc = "COMPARATOR_A"]
    pub COMPARATOR_A: &'a COMPARATOR_A,
    #[doc = "TIMER1_A3"]
    pub TIMER1_A3: &'a TIMER1_A3,
    #[doc = "TIMER0_A3"]
    pub TIMER0_A3: &'a TIMER0_A3,
    #[doc = "USCI_B0_I2C_MODE"]
    pub USCI_B0_I2C_MODE: &'a USCI_B0_I2C_MODE,
    #[doc = "TLV_CALIBRATION_DATA"]
    pub TLV_CALIBRATION_DATA: &'a TLV_CALIBRATION_DATA,
    #[doc = "ADC10"]
    pub ADC10: &'a ADC10,
    #[doc = "USCI_B0_SPI_MODE"]
    pub USCI_B0_SPI_MODE: &'a USCI_B0_SPI_MODE,
    #[doc = "USCI_A0_SPI_MODE"]
    pub USCI_A0_SPI_MODE: &'a USCI_A0_SPI_MODE,
    #[doc = "SPECIAL_FUNCTION"]
    pub SPECIAL_FUNCTION: &'a SPECIAL_FUNCTION,
    #[doc = "PORT_3_4"]
    pub PORT_3_4: &'a PORT_3_4,
    #[doc = "CALIBRATION_DATA"]
    pub CALIBRATION_DATA: &'a CALIBRATION_DATA,
    #[doc = "PORT_1_2"]
    pub PORT_1_2: &'a PORT_1_2,
    #[doc = "SYSTEM_CLOCK"]
    pub SYSTEM_CLOCK: &'a SYSTEM_CLOCK,
}
impl<'a> Peripherals<'a> {
    #[doc = r" Grants access to all the peripherals"]
    pub unsafe fn all() -> Self {
        Peripherals {
            FLASH: &*FLASH.get(),
            USCI_A0_UART_MODE: &*USCI_A0_UART_MODE.get(),
            WATCHDOG_TIMER: &*WATCHDOG_TIMER.get(),
            COMPARATOR_A: &*COMPARATOR_A.get(),
            TIMER1_A3: &*TIMER1_A3.get(),
            TIMER0_A3: &*TIMER0_A3.get(),
            USCI_B0_I2C_MODE: &*USCI_B0_I2C_MODE.get(),
            TLV_CALIBRATION_DATA: &*TLV_CALIBRATION_DATA.get(),
            ADC10: &*ADC10.get(),
            USCI_B0_SPI_MODE: &*USCI_B0_SPI_MODE.get(),
            USCI_A0_SPI_MODE: &*USCI_A0_SPI_MODE.get(),
            SPECIAL_FUNCTION: &*SPECIAL_FUNCTION.get(),
            PORT_3_4: &*PORT_3_4.get(),
            CALIBRATION_DATA: &*CALIBRATION_DATA.get(),
            PORT_1_2: &*PORT_1_2.get(),
            SYSTEM_CLOCK: &*SYSTEM_CLOCK.get(),
        }
    }
}
